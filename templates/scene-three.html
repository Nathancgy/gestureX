<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GestureX - Geometric Prisms</title>
    <!-- Backup failsafe redirect if JavaScript freezes -->
    <meta http-equiv="refresh" content="180;url=/scene-four">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f5;
            font-family: 'Arial', sans-serif;
            color: #333;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
        .content {
            position: relative;
            z-index: 2;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            pointer-events: none;
        }
        .instructions {
            background-color: rgba(255, 255, 255, 0.1);
            border-top: 1px solid rgba(0, 0, 0, 0.2);
            width: 100%;
            padding: 15px 0;
            text-align: center;
            opacity: 0;
            animation: fade-in 3s ease-in forwards;
            animation-delay: 3s;
        }
        .portal-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 1s ease-in-out, background-color 0.3s;
            pointer-events: auto;
            z-index: 100;
        }
        .portal-button.visible {
            opacity: 0.7;
        }
        .portal-button:hover {
            background-color: rgba(255, 255, 255, 0.4);
        }
        .portal-button-inner {
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(150,180,220,0.6) 100%);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .instruction-text {
            max-width: 800px;
            margin: 0 auto;
            font-size: 1rem;
            line-height: 1.6;
            color: rgba(0, 0, 0, 0.7);
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 2s ease-out;
        }
        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-text {
            font-size: 2rem;
            letter-spacing: 0.5rem;
            color: rgba(0, 0, 0, 0.6);
            text-transform: uppercase;
        }
        
        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c4zIaFAAAA20lEQVR4nO3UMW7CQBSEYbMYB0MACw5w9/7XhCKFjLRrrUGK+j6tVit9I42I49XdYLtfbVUR1dIXlUQUb4exRNXfmEfzrdRlonqyTLRe4oncNE8Unt8gk07UfQP3iars8lKVifKgIjNPVCetiExtvpFIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP6b66OnD0sU+PkU8kmkQ8PqHmfF4sLYervcrJYinvtSvabq2sPgc0VRdFdnYrGp3u6D5UVEcdDVu1xUZSJJSgZ4F9O3qixoNvsvXq/cqtlmMrYAAAAASUVORK5CYII=');
            opacity: 0.07;
            pointer-events: none;
            z-index: 10;
        }
        
        .ink-splatters {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9;
        }
    </style>
</head>
<body>
    <div class="loading" id="loadingScreen">
        <div class="loading-text">Entering The Grid</div>
    </div>
    
    <canvas id="prismCanvas"></canvas>
    
    <div class="paper-texture"></div>
    <div class="ink-splatters"></div>
    
    <div class="content">
        <div class="instructions">
            <p class="instruction-text">Interact with the geometric prisms to release their trapped light.</p>
        </div>
    </div>
    
    <div id="portalButton" class="portal-button">
        <div class="portal-button-inner"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        // Hide loading screen after 3 seconds
        setTimeout(() => {
            document.getElementById('loadingScreen').classList.add('hidden');
        }, 3000);
        
        // Global redirect tracking to ensure consistent transitions
        window.redirectInProgress = false;
        
        // Set up canvas
        const canvas = document.getElementById('prismCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Connect to the WebSocket server
        const socket = io();
        
        // Hand landmark data and gesture state
        let handLandmarks = null;
        let currentGesture = '';
        let lastGesture = '';
        let handPosition = null;
        let isClicking = false;
        let isHolding = false;
        let isFistClosed = false;
        
        // Star gesture detection and transition state
        let starGestureTimer = 0;      // Time the star gesture has been held
        let starTransition = {
            active: false,
            progress: 0,
            startTime: 0,
            phase: 0,     // 0=gathering, 1=burst, 2=galaxy formation, 3=rotation
            stars: [],    // Star particles
            galaxyParticles: [],
            spiralRotation: 0,
            redirectStarted: false
        };
        
        // Gesture alternation tracking
        let gestureHistory = [];
        let lastGestureChangeTime = 0;
        let gestureChangeTimes = [];  // Store timestamps of gesture changes
        let alternationRate = 0;      // Alternations per second
        let isNetworkOverloaded = false;
        let overloadProgress = 0;     // 0 to 1 (full overload)
        let collapsePhase = 0;        // 0=none, 1=overload, 2=faces, 3=shards, 4=fluid
        let collapseStartTime = 0;
        
        let portalTransition = {
            active: false,
            progress: 0,
            startTime: 0,
            portalSize: 0,
            flashProgress: 0,
            lightParticles: [],
            portalRotation: 0,
            isDramatic: false,
            portalSizeMultiplier: 1
        };
        
        // Animation timing
        let time = 0;
        let lastFrameTime = 0;
        let deltaTime = 0;
        
        // Transition safety variables
        let redirectInitiated = false;
        let sceneStartTime = Date.now();
        const MAX_SCENE_DURATION = 180000; // Force transition after 3 minutes
        
        // Camera movement for parallax effect
        let cameraX = 0;
        let cameraY = 0;
        let targetCameraX = 0;
        let targetCameraY = 0;
        
        // Particle system
        const particles = [];
        const maxParticles = 200;
        
        // Ink splatter system
        const inkSplatters = [];
        const maxInkSplatters = 12;
        
        // Grid configuration
        const gridSpacing = 200;
        const gridRows = Math.ceil(canvas.height / gridSpacing) + 4; // Add extras for scrolling
        const gridCols = Math.ceil(canvas.width / gridSpacing) + 4;
        const gridOffsetX = -gridSpacing * 2; // Negative offset to extend beyond visible area
        const gridOffsetY = -gridSpacing * 2;
        
        // Prism types: hexagons and tetrahedrons
        const prismTypes = ['hexagon', 'tetrahedron'];
        
        // Array to store all prisms
        const prisms = [];
        
        // Arrays to track clones, light beams and cracks
        const prismClones = [];
        const lightBeams = [];
        const cracks = [];
        const ichorDrops = [];
        
        // Network connection tracking
        const connections = [];
        const maxConnections = 100;
        
        // Reflection pools that show distorted versions of previous scenes
        const reflectionPools = [];
        
        // Arrays for collapse sequence
        const shards = [];
        const fluidDroplets = [];
        const facesData = [];
        
        // Preload face images for distorted reflections
        const faceImages = [];
        const faceCount = 5;  // Number of distorted faces to preload
        
        // Initialize collapse sequence variables
        let collapseProgress = 0;
        let mercuryLevel = 0;
        let nextSceneRedirect = false;
        
        // Visual feedback variables for alternations
        let alternationFlash = 0;     // Flash effect intensity (0-1)
        let alternationCount = 0;     // Count of meaningful alternations
        let countdownLevel = 0;       // Determines what number to show (3,2,1)
        
        // Create prism grid
        function createPrismGrid() {
            for (let row = 0; row < gridRows; row++) {
                for (let col = 0; col < gridCols; col++) {
                    // Stagger every other row
                    const staggerX = row % 2 === 0 ? 0 : gridSpacing / 2;
                    
                    // Calculate position
                    const x = gridOffsetX + col * gridSpacing + staggerX;
                    const y = gridOffsetY + row * gridSpacing;
                    
                    // Randomize type - more hexagons than tetrahedrons
                    const type = Math.random() > 0.3 ? 'hexagon' : 'tetrahedron';
                    
                    // Create prism with randomized attributes
                    const prism = {
                        x, y,
                        type,
                        size: 40 + Math.random() * 30,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.01,
                        pulsePhase: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.5 + Math.random() * 0.5,
                        lightLevel: 0.2 + Math.random() * 0.3, // Initial trapped light level
                        activated: false,
                        activationProgress: 0,
                        lineThickness: 1 + Math.random(),
                        zOffset: Math.random(),
                        // Random color in muted tones for light
                        color: {
                            r: 20 + Math.floor(Math.random() * 30),
                            g: 20 + Math.floor(Math.random() * 30),
                            b: 40 + Math.floor(Math.random() * 40)
                        }
                    };
                    
                    prisms.push(prism);
                }
            }
        }
        
        // Initialize button behavior
        document.getElementById('portalButton').addEventListener('click', function() {
            if (!portalTransition.active && !isNetworkOverloaded) {
                triggerPortalTransition();
            }
        });
        
        // Show portal button after some activated prisms exist
        function checkPortalButtonVisibility() {
            const activatedCount = prisms.filter(p => p.activated).length;
            if (activatedCount >= 3) {
                document.getElementById('portalButton').classList.add('visible');
            }
        }
        
        // Listen for landmarks and gesture data
        socket.on('landmarks', function(data) {
            handLandmarks = JSON.parse(data);
            
            if (handLandmarks && handLandmarks.length > 0) {
                // Get index finger position (usually index 8)
                const indexTip = handLandmarks[8] || handLandmarks[0];
                handPosition = {
                    x: indexTip.x * canvas.width,
                    y: indexTip.y * canvas.height
                };
                
                // Update camera target for parallax effect
                targetCameraX = (handPosition.x - canvas.width / 2) * 0.05;
                targetCameraY = (handPosition.y - canvas.height / 2) * 0.05;
                
                // Detect star gesture (five fingers spread in a star pattern)
                if (handLandmarks.length >= 21 && !portalTransition.active && !isNetworkOverloaded && collapsePhase === 0 && !starTransition.active) {
                    // Get fingertip landmarks (indices 4, 8, 12, 16, 20)
                    const thumbTip = handLandmarks[4];
                    const indexTip = handLandmarks[8];
                    const middleTip = handLandmarks[12];
                    const ringTip = handLandmarks[16];
                    const pinkyTip = handLandmarks[20];
                    
                    // Get palm center (approximate using landmark 0)
                    const palmCenter = handLandmarks[0];
                }
            }
        });
        
        // Listen for landmarks and gesture data
        socket.on('gesture', function(data) {
            lastGesture = currentGesture;
            currentGesture = data;
            
            // Create a more forgiving version of Hold detection
            // Consider both "Hold" and "Closed_Fist" as equivalent for Hold operations
            const isEffectivelyHolding = currentGesture === 'Hold' || currentGesture === 'Closed_Fist';
            const wasEffectivelyHolding = lastGesture === 'Hold' || lastGesture === 'Closed_Fist';
            
            // Track gesture changes for alternation detection
            if (currentGesture !== lastGesture) {
                const now = performance.now();
                
                // Only track Click and Hold/Fist alternations
                if ((currentGesture === 'Click' || isEffectivelyHolding) && 
                    (lastGesture === 'Click' || wasEffectivelyHolding)) {
                    
                    // Calculate time since last gesture change
                    const timeSinceLastChange = now - lastGestureChangeTime;
                    
                    // Store gesture and time - normalize gesture names for history
                    gestureHistory.push({
                        from: wasEffectivelyHolding ? 'Hold' : lastGesture,
                        to: isEffectivelyHolding ? 'Hold' : currentGesture,
                        time: now
                    });
                    
                    // Keep history manageable
                    if (gestureHistory.length > 20) {
                        gestureHistory.shift();
                    }
                    
                    // Store timing data for rate calculation
                    gestureChangeTimes.push(now);
                    
                    // Keep only recent changes (last 8 seconds instead of 3)
                    const eightSecondsAgo = now - 8000;
                    gestureChangeTimes = gestureChangeTimes.filter(time => time > eightSecondsAgo);
                    
                    // Calculate alternation rate (changes per second)
                    if (gestureChangeTimes.length > 1) {
                        const timeSpan = (now - gestureChangeTimes[0]) / 1000; // in seconds
                        alternationRate = timeSpan > 0 ? gestureChangeTimes.length / timeSpan : 0;
                        
                        // Check for network overload condition - much easier threshold (0.5 Hz instead of 3 Hz)
                        if (alternationRate > 0.5 && gestureChangeTimes.length >= 3 && !isNetworkOverloaded && !portalTransition.active) {
                            // Also increase progress faster to make it take effect sooner
                            overloadProgress += 0.15;
                            
                            // Trigger visual feedback with every alternation that increases progress
                            alternationFlash = 1.0; // Full flash intensity
                            
                            // Increment alternation count if we're making progress
                            alternationCount++;
                            
                            // Update countdown level based on progress
                            if (overloadProgress >= 0.66) {
                                countdownLevel = 1; // Show "1"
                            } else if (overloadProgress >= 0.33) {
                                countdownLevel = 2; // Show "2"
                            } else {
                                countdownLevel = 3; // Show "3" 
                            }
                            
                            if (overloadProgress >= 1) {
                                triggerNetworkOverload();
                                alternationCount = 0;
                                countdownLevel = 0;
                            }
                        } else if (alternationRate <= 0.4) {
                            // Recover gradually if alternation slows down
                            overloadProgress = Math.max(0, overloadProgress - 0.02);
                            
                            // Reset countdown if we drop too low
                            if (overloadProgress < 0.33) {
                                countdownLevel = 3;
                            } else if (overloadProgress < 0.66) {
                                countdownLevel = 2;
                            }
                            
                            // Also reset alternation count if we lose too much progress
                            if (overloadProgress < 0.1) {
                                alternationCount = 0;
                            }
                        }
                    }
                }
                
                lastGestureChangeTime = now;
            }
            
            // Process normal gesture actions if not in collapse mode
            if (collapsePhase === 0) {
                if (currentGesture === 'Click' && !isClicking) {
                    isClicking = true;
                    handleClick();
                } else if (currentGesture !== 'Click' && isClicking) {
                    isClicking = false;
                }
                
                // More forgiving Hold gesture handling
                if (isEffectivelyHolding && !isHolding) {
                    isHolding = true;
                    handleHold();
                } else if (!isEffectivelyHolding && isHolding) {
                    isHolding = false;
                }
                
                // Handle Closed_Fist gesture for portal activation
                // Only trigger portal if closed fist is detected but not categorized as holding
                if (currentGesture === 'Closed_Fist' && !isFistClosed && !isHolding && !portalTransition.active) {
                    isFistClosed = true;
                    triggerPortalTransition();
                } else if (currentGesture !== 'Closed_Fist') {
                    isFistClosed = false;
                }
            }
        });
        
        // Handle click gesture
        function handleClick() {
            if (!handPosition) return;
            
            // Check for interaction with portal button first
            const portalButton = document.getElementById('portalButton');
            if (portalButton.classList.contains('visible')) {
                const rect = portalButton.getBoundingClientRect();
                if (handPosition.x >= rect.left && 
                    handPosition.x <= rect.right && 
                    handPosition.y >= rect.top && 
                    handPosition.y <= rect.bottom) {
                    // Clicked on portal button
                    if (!portalTransition.active && !isNetworkOverloaded) {
                        triggerPortalTransition();
                        return;
                    }
                }
            }
            
            let interacted = false;
            
            // Check for interaction with prisms
            for (let prism of prisms) {
                const dx = prism.x - handPosition.x + cameraX;
                const dy = prism.y - handPosition.y + cameraY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < prism.size * 1.2) {
                    // Activate this prism if not already fully activated
                    if (!prism.activated || prism.activationProgress < 1) {
                        prism.activated = true;
                        
                        // Create activation animation
                        createActivationParticles(prism);
                        
                        // Create ink splatter at the interaction point
                        createInkSplatter(handPosition.x, handPosition.y);
                        
                        // Create clones that orbit the original prism
                        createPrismClones(prism);
                        
                        // Try to connect to nearby activated prisms
                        createLightBridges(prism);
                        
                        interacted = true;
                    } else {
                        // If already fully activated, add energy to the network
                        energizeLightNetwork(prism);
                    }
                    break;
                }
            }
            
            // If didn't interact with any prism, still create ink splatter
            if (!interacted) {
                createInkSplatter(handPosition.x, handPosition.y, true);
            }
        }
        
        // Handle the Hold gesture
        function handleHold() {
            if (!handPosition) return;
            
            // Check for interaction with prisms
            for (let prism of prisms) {
                const dx = prism.x - handPosition.x + cameraX;
                const dy = prism.y - handPosition.y + cameraY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < prism.size * 1.8) {
                    // Create cracks on this prism
                    createCracksOnPrism(prism);
                    
                    // Create a reflection pool that shows distorted versions of previous scenes
                    if (Math.random() > 0.7) {
                        createReflectionPool(prism);
                    }
                    
                    // Break any connections to this prism
                    breakConnections(prism);
                    
                    // Visual and audio effects
                    createIchorEffect(prism);
                    break;
                }
            }
        }
        
        // Create particles for prism activation
        function createActivationParticles(prism) {
            const particleCount = 15 + Math.floor(Math.random() * 10);
            const baseColor = prism.color;
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 20 + Math.random() * 40;
                const size = 2 + Math.random() * 4;
                
                // Randomize color slightly for artistic variation
                const r = baseColor.r + Math.floor(Math.random() * 50);
                const g = baseColor.g + Math.floor(Math.random() * 50);
                const b = baseColor.b + Math.floor(Math.random() * 50);
                
                // Create particle
                particles.push({
                    x: prism.x,
                    y: prism.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: size,
                    color: { r, g, b },
                    alpha: 0.7 + Math.random() * 0.3,
                    life: 1.0,
                    decay: 0.02 + Math.random() * 0.03,
                    inkDrop: Math.random() > 0.5
                });
                
                // Remove oldest particles if we exceed the maximum
                if (particles.length > maxParticles) {
                    particles.shift();
                }
            }
        }
        
        // Create an ink splatter at the specified position
        function createInkSplatter(x, y, isSmall = false) {
            // DOM-based ink splatter for organic look
            const inkSplattersContainer = document.querySelector('.ink-splatters');
            
            // Create splatter element
            const splatter = document.createElement('div');
            splatter.style.position = 'absolute';
            splatter.style.left = `${x}px`;
            splatter.style.top = `${y}px`;
            splatter.style.transform = `translate(-50%, -50%) rotate(${Math.random() * 360}deg)`;
            
            // Randomize size
            const size = isSmall ? 20 + Math.random() * 40 : 50 + Math.random() * 100;
            splatter.style.width = `${size}px`;
            splatter.style.height = `${size}px`;
            
            // Create SVG for organic shape
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute("viewBox", "0 0 100 100");
            
            // Create random blob shape
            const path = document.createElementNS(svgNS, "path");
            
            // Generate random blob path data
            let pathData = "M50,50 ";
            const points = 8 + Math.floor(Math.random() * 6);
            const angleStep = (Math.PI * 2) / points;
            
            for (let i = 0; i < points; i++) {
                const angle = i * angleStep;
                const radius = 30 + Math.random() * 20;
                const x = 50 + Math.cos(angle) * radius;
                const y = 50 + Math.sin(angle) * radius;
                
                // Add bezier curve for more organic look
                const controlRadius = radius * (0.5 + Math.random() * 0.8);
                const controlAngle1 = angle - angleStep * 0.3;
                const controlAngle2 = angle + angleStep * 0.3;
                
                const cx1 = 50 + Math.cos(controlAngle1) * controlRadius;
                const cy1 = 50 + Math.sin(controlAngle1) * controlRadius;
                const cx2 = 50 + Math.cos(controlAngle2) * controlRadius;
                const cy2 = 50 + Math.sin(controlAngle2) * controlRadius;
                
                pathData += `C ${cx1},${cy1} ${cx2},${cy2} ${x},${y} `;
            }
            
            pathData += "Z";
            path.setAttribute("d", pathData);
            path.setAttribute("fill", "rgba(0, 0, 0, 0.6)");
            
            svg.appendChild(path);
            splatter.appendChild(svg);
            
            // Add to DOM
            inkSplattersContainer.appendChild(splatter);
            
            // Remember splatter for removal
            inkSplatters.push({
                element: splatter,
                creationTime: time,
                lifespan: 4 + Math.random() * 3
            });
            
            // Remove oldest splatters if exceed maximum
            if (inkSplatters.length > maxInkSplatters) {
                const oldest = inkSplatters.shift();
                oldest.element.remove();
            }
        }
        
        // Update ink splatters (fade out over time)
        function updateInkSplatters() {
            for (let i = inkSplatters.length - 1; i >= 0; i--) {
                const splatter = inkSplatters[i];
                const age = time - splatter.creationTime;
                
                if (age > splatter.lifespan) {
                    // Remove expired splatters
                    splatter.element.remove();
                    inkSplatters.splice(i, 1);
                } else {
                    // Fade out as they age
                    const opacity = Math.max(0, 0.6 - (age / splatter.lifespan) * 0.6);
                    splatter.element.style.opacity = opacity;
                }
            }
        }
        
        // Update and draw particles
        function updateAndDrawParticles() {
            ctx.save();
            
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Update particle position and life
                particle.x += particle.vx * deltaTime;
                particle.y += particle.vy * deltaTime;
                particle.life -= particle.decay * deltaTime;
                
                // Remove dead particles
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Slow down particles
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                
                // Apply camera offset
                const drawX = particle.x - cameraX;
                const drawY = particle.y - cameraY;
                
                // Skip rendering if offscreen
                if (drawX < -50 || drawX > canvas.width + 50 ||
                    drawY < -50 || drawY > canvas.height + 50) {
                    continue;
                }
                
                // Draw particle based on type
                if (particle.inkDrop) {
                    // Ink drop style
                    const radius = particle.size * particle.life * 2;
                    
                    // Draw with ink wash effect
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, radius, 0, Math.PI * 2);
                    
                    // Black ink with varying opacity
                    ctx.fillStyle = `rgba(0, 0, 0, ${particle.alpha * particle.life * 0.4})`;
                    ctx.fill();
                    
                    // Add some splatter for artistic effect
                    if (particle.life > 0.7 && Math.random() > 0.7) {
                        const splatterCount = 1 + Math.floor(Math.random() * 3);
                        
                        for (let j = 0; j < splatterCount; j++) {
                            const splatterAngle = Math.random() * Math.PI * 2;
                            const splatterDist = radius * (1 + Math.random());
                            
                            ctx.beginPath();
                            ctx.arc(
                                drawX + Math.cos(splatterAngle) * splatterDist,
                                drawY + Math.sin(splatterAngle) * splatterDist,
                                radius * 0.5 * Math.random(),
                                0,
                                Math.PI * 2
                            );
                            ctx.fillStyle = `rgba(0, 0, 0, ${particle.alpha * particle.life * 0.3})`;
                            ctx.fill();
                        }
                    }
                } else {
                    // Light particle style - bright center with color
                    const r = particle.color.r;
                    const g = particle.color.g;
                    const b = particle.color.b;
                    const alpha = particle.alpha * particle.life;
                    
                    // Draw with simple circular shape
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, particle.size * particle.life, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.fill();
                    
                    // Add bright center highlight
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, particle.size * particle.life * 0.5, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
                    ctx.fill();
                }
            }
            
            ctx.restore();
        }
        
        // Draw function for different prism types
        function drawPrism(prism) {
            // Calculate pulse effect
            const pulse = Math.sin(time * prism.pulseSpeed + prism.pulsePhase) * 0.2 + 0.8;
            
            // Calculate current light level
            let lightLevel = prism.lightLevel;
            if (prism.activated) {
                prism.activationProgress = Math.min(1, prism.activationProgress + deltaTime * 0.5);
                lightLevel = prism.lightLevel + prism.activationProgress * (1 - prism.lightLevel);
            }
            
            // Apply camera offset for parallax effect
            const drawX = prism.x - cameraX;
            const drawY = prism.y - cameraY;
            
            // Skip rendering if offscreen (with some margin)
            if (drawX < -prism.size - 100 || drawX > canvas.width + prism.size + 100 ||
                drawY < -prism.size - 100 || drawY > canvas.height + prism.size + 100) {
                return;
            }
            
            ctx.save();
            ctx.translate(drawX, drawY);
            ctx.rotate(prism.rotation);
            
            // Draw based on prism type
            if (prism.type === 'hexagon') {
                drawHexagon(prism, pulse, lightLevel);
            } else {
                drawTetrahedron(prism, pulse, lightLevel);
            }
            
            ctx.restore();
        }
        
        // Draw a hexagonal prism
        function drawHexagon(prism, pulse, lightLevel) {
            const size = prism.size * pulse;
            const sides = 6;
            
            // Draw outline
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            // Inner light fill
            const r = prism.color.r + (200 * lightLevel);
            const g = prism.color.g + (200 * lightLevel);
            const b = prism.color.b + (200 * lightLevel);
            
            // Draw liquid light inside with paper texture effect
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.1 + lightLevel * 0.3})`;
            ctx.fill();
            
            // Ink-style outline
            ctx.strokeStyle = `rgba(0, 0, 0, ${0.8 + (lightLevel * 0.2)})`;
            ctx.lineWidth = prism.lineThickness * (1 + lightLevel * 0.5);
            ctx.stroke();
            
            // Add brush stroke texture to activated prisms
            if (prism.activated && lightLevel > 0.5) {
                // Draw brush strokes to suggest movement of light
                const strokes = 4 + Math.floor(lightLevel * 5);
                
                for (let i = 0; i < strokes; i++) {
                    const angle = (i / strokes) * Math.PI * 2;
                    const innerRadius = size * 0.3;
                    const outerRadius = size * 0.7;
                    
                    const x1 = Math.cos(angle) * innerRadius;
                    const y1 = Math.sin(angle) * innerRadius;
                    const x2 = Math.cos(angle) * outerRadius;
                    const y2 = Math.sin(angle) * outerRadius;
                    
                    // Control points for curved brush stroke
                    const cx = Math.cos(angle + Math.PI * 0.1) * (innerRadius + outerRadius) * 0.5;
                    const cy = Math.sin(angle + Math.PI * 0.1) * (innerRadius + outerRadius) * 0.5;
                    
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.quadraticCurveTo(cx, cy, x2, y2);
                    
                    ctx.strokeStyle = `rgba(${r+30}, ${g+30}, ${b+30}, ${0.3 * lightLevel})`;
                    ctx.lineWidth = 1 + Math.random() * 2;
                    ctx.stroke();
                }
            }
            
            // Draw internal structure - ink lines suggesting depth
            const internalLines = 3;
            for (let i = 0; i < internalLines; i++) {
                const angle = (i / internalLines) * Math.PI;
                
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * size, Math.sin(angle) * size);
                ctx.lineTo(Math.cos(angle + Math.PI) * size, Math.sin(angle + Math.PI) * size);
                ctx.strokeStyle = `rgba(20, 20, 40, ${0.3 + lightLevel * 0.2})`;
                ctx.lineWidth = 0.5 * prism.lineThickness;
                ctx.stroke();
            }
            
            // Draw pulsating light center
            const innerRadius = size * 0.5 * lightLevel;
            if (innerRadius > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, innerRadius);
                gradient.addColorStop(0, `rgba(${r + 50}, ${g + 50}, ${b + 50}, ${Math.min(1, lightLevel * 2) * pulse})`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            // Add heartbeat pulse effect for activated prisms
            if (prism.activated && prism.activationProgress > 0.5) {
                const heartbeatPhase = time * 3 % Math.PI;
                const heartbeatPulse = Math.exp(-heartbeatPhase * 3) * Math.sin(heartbeatPhase * 10);
                
                if (heartbeatPulse > 0.1) {
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.8 * heartbeatPulse, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${heartbeatPulse * 0.3})`;
                    ctx.lineWidth = 2 * heartbeatPulse;
                    ctx.stroke();
                }
            }
        }
        
        // Draw a tetrahedral prism
        function drawTetrahedron(prism, pulse, lightLevel) {
            const size = prism.size * pulse;
            
            // Define four points of tetrahedron (simplified 2D representation)
            const points = [
                { x: 0, y: -size },
                { x: -size * 0.866, y: size * 0.5 },
                { x: size * 0.866, y: size * 0.5 },
                { x: 0, y: -size * 0.3 }  // This is technically the "hidden" fourth point
            ];
            
            // Draw base (visible triangle)
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[1].x, points[1].y);
            ctx.lineTo(points[2].x, points[2].y);
            ctx.closePath();
            
            // Inner light fill
            const r = prism.color.r + (200 * lightLevel);
            const g = prism.color.g + (200 * lightLevel);
            const b = prism.color.b + (200 * lightLevel);
            
            // Fill with liquid light effect
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.1 + lightLevel * 0.3})`;
            ctx.fill();
            
            // Ink-style outline
            ctx.strokeStyle = `rgba(0, 0, 0, ${0.8 + (lightLevel * 0.2)})`;
            ctx.lineWidth = prism.lineThickness * (1 + lightLevel * 0.5);
            ctx.stroke();
            
            // Draw internal lines for depth effect
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            ctx.lineTo(points[3].x, points[3].y);
            ctx.strokeStyle = `rgba(20, 20, 40, ${0.5 * lightLevel})`;
            ctx.lineWidth = 0.5 * prism.lineThickness;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(points[1].x, points[1].y);
            ctx.lineTo(points[3].x, points[3].y);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(points[2].x, points[2].y);
            ctx.lineTo(points[3].x, points[3].y);
            ctx.stroke();
            
            // Draw pulsating light center
            if (lightLevel > 0.3) {
                const centerX = (points[0].x + points[1].x + points[2].x) / 3;
                const centerY = (points[0].y + points[1].y + points[2].y) / 3;
                const innerRadius = size * 0.3 * lightLevel;
                
                ctx.beginPath();
                ctx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
                const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, innerRadius);
                gradient.addColorStop(0, `rgba(${r + 50}, ${g + 50}, ${b + 50}, ${Math.min(1, lightLevel * 2) * pulse})`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
        }
        
        // Main animation loop
        function animate(currentTime) {
            // Calculate delta time for smooth animations
            if (!lastFrameTime) lastFrameTime = currentTime;
            deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            
            // Cap delta time to avoid large jumps
            if (deltaTime > 0.1) deltaTime = 0.1;
            
            // Update time for animations
            time += deltaTime;
            
            // Update camera position for parallax
            cameraX += (targetCameraX - cameraX) * deltaTime * 3;
            cameraY += (targetCameraY - cameraY) * deltaTime * 3;
            
            // Fade out alternation flash
            if (alternationFlash > 0) {
                alternationFlash = Math.max(0, alternationFlash - deltaTime * 4);
            }
            
            // Rotate prisms
            for (let prism of prisms) {
                prism.rotation += prism.rotationSpeed;
            }
            
            // Update ink splatters
            updateInkSplatters();
            
            // Check if we should show the portal button
            checkPortalButtonVisibility();
            
            // Safety check 0: Detect JavaScript execution slowdown
            const currentExecutionTime = Date.now();
            if (!window.lastExecutionTime) {
                window.lastExecutionTime = currentExecutionTime;
            } else {
                const executionGap = currentExecutionTime - window.lastExecutionTime;
                // If the gap between frames is too long (over 500ms), it might indicate a freeze
                if (executionGap > 500 && collapsePhase > 0) {
                    console.log("Detected potential execution slowdown, forcing transition");
                    safeRedirect();
                    return;
                }
                window.lastExecutionTime = currentExecutionTime;
            }
            
            // Update collapse sequence if active
            if (collapsePhase > 0) {
                try {
                updateCollapseSequence();
                } catch (e) {
                    // If any error occurs during collapse animation, force transition
                    console.error("Error in collapse sequence:", e);
                    safeRedirect();
                    return;
                }
            }
            
            // Clear canvas with light paper texture background
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw alternation flash if active
            if (alternationFlash > 0) {
                ctx.fillStyle = `rgba(255, 0, 0, ${alternationFlash * 0.15})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw subtle grid pattern
            drawGridPattern();
            
            // Update and draw reflection pools (behind everything)
            updateAndDrawReflectionPools();
            
            // If portal transition is active, update and render it
            if (portalTransition.active) {
                updateAndDrawPortalTransition();
            } else if (collapsePhase > 0) {
                // Draw collapse sequence
                try {
                drawCollapseSequence();
                } catch (e) {
                    // If any error occurs during collapse drawing, force transition
                    console.error("Error drawing collapse sequence:", e);
                    safeRedirect();
                    return;
                }
            } else {
                // Only draw these when not in portal transition or collapse
                // Update and draw light beams
                updateAndDrawLightBeams();
                
                // Update and draw connections between prisms
                updateAndDrawConnections();
                
                // Update and draw ichor drops
                updateAndDrawIchorDrops();
                
                // Sort prisms by y position for pseudo-3D layering
                prisms.sort((a, b) => (a.y + a.zOffset * 100) - (b.y + b.zOffset * 100));
                
                // Draw all prisms
                for (let prism of prisms) {
                    drawPrism(prism);
                }
                
                // Update and draw prism clones
                updateAndDrawPrismClones();
                
                // Draw cracks on prisms
                drawCracks();
                
                // Draw overload indicator if needed
                if (overloadProgress > 0) {
                    drawOverloadIndicator();
                }
            }
            
            // Update and draw particles
            updateAndDrawParticles();
            
            // Draw hand interaction effects
            drawHandInteraction();
            
            // Safety check 1: Force transition if maximum scene duration exceeded
            if (!window.redirectInProgress && (Date.now() - sceneStartTime > MAX_SCENE_DURATION)) {
                console.log("Safety timeout: Maximum scene duration exceeded, forcing transition to next scene");
                safeRedirect();
                return; // Stop animation immediately
            }
            
            // Safety check 2: Force transition if collapse phase has been active too long
            if (!window.redirectInProgress && collapsePhase > 0) {
                const phaseElapsedTime = time - collapseStartTime;
                const phaseTimeout = collapsePhase === 4 ? 15 : 20; // Reduce time for final phase
                
                if (phaseElapsedTime > phaseTimeout) {
                    console.log(`Safety timeout: Collapse phase ${collapsePhase} running too long, forcing transition`);
                    safeRedirect();
                return; // Stop animation immediately
                }
            }
            
            // Continue animation only if not redirecting
            if (!window.redirectInProgress) {
                try {
                requestAnimationFrame(animate);
                } catch (e) {
                    console.error("Error requesting animation frame:", e);
                    safeRedirect();
                }
            }
        }
        
        // Safe redirect function to handle all transitions
        function safeRedirect() {
            // Immediately return if already redirecting
            if (window.redirectInProgress) {
                return;
            }
            
            // Set the flag first to prevent any other redirects
            window.redirectInProgress = true;
            console.log("Redirecting to scene four");
            
            try {
                // Create final dramatic zoom effect before redirect
                if (!window.zoomTransition) {
                    createZoomTransition();
                    
                    // Allow zoom effect to play out for 2 seconds before actual redirect
                    setTimeout(() => {
                        finalRedirect();
                    }, 2000);
                } else {
                    // If zoom already active, proceed with redirect
                    finalRedirect();
                }
            } catch (e) {
                console.error("Error during redirect setup:", e);
                // Force navigation as last resort
                window.location.replace('/scene-four');
            }
        }
        
        // Final redirect execution
        function finalRedirect() {
            try {
                // Clean up any resources or animations that might be causing issues
                // Cancel all animations
                cancelAnimationFrame(animate);
                
                // Clear large arrays that might be causing memory issues
                particles.length = 0;
                fluidDroplets.length = 0;
                connections.length = 0;
                prisms.length = 0;
                shards.length = 0;
            
            // Add meta refresh as immediate fallback
            const meta = document.createElement('meta');
            meta.httpEquiv = 'refresh';
            meta.content = '0;url=/scene-four';
            document.head.appendChild(meta);
            
                // Use both setTimeout and direct navigation for redundancy
                setTimeout(() => {
            window.location.href = '/scene-four';
                }, 0);
                
                // Direct immediate navigation
                window.location.href = '/scene-four';
            } catch (e) {
                console.error("Error during redirect:", e);
                // Force navigation as last resort
                window.location.replace('/scene-four');
            }
        }
        
        // Draw subtle grid background
        function drawGridPattern() {
            const gridSize = 50;
            const minorLines = 10;
            
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.lineWidth = 0.5;
            
            // Offset grid by camera position for parallax
            const offsetX = cameraX * 0.2 % gridSize;
            const offsetY = cameraY * 0.2 % gridSize;
            
            // Draw horizontal lines
            for (let y = offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw vertical lines
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Draw major grid lines
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            
            // Major horizontal lines
            for (let y = offsetY; y < canvas.height; y += gridSize * minorLines) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Major vertical lines
            for (let x = offsetX; x < canvas.width; x += gridSize * minorLines) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }
        
        // Draw hand interaction visuals
        function drawHandInteraction() {
            if (!handPosition) return;
            
            ctx.save();
            
            // Draw hand landmarks if available
            if (handLandmarks && handLandmarks.length > 0) {
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 1;
                
                // Draw connections between landmarks
                for (let i = 0; i < handLandmarks.length - 1; i++) {
                    // Only connect certain landmarks to create a simplified hand skeleton
                    if ((i % 4 === 0 || i === 8) && i > 0) {
                        const prev = handLandmarks[Math.floor(i / 4) * 4 - 1] || handLandmarks[0];
                        const curr = handLandmarks[i];
                        
                        ctx.beginPath();
                        ctx.moveTo(prev.x * canvas.width, prev.y * canvas.height);
                        ctx.lineTo(curr.x * canvas.width, curr.y * canvas.height);
                        ctx.stroke();
                    }
                }
                
                // Draw landmark points with different sizes based on importance
                handLandmarks.forEach((point, index) => {
                    const x = point.x * canvas.width;
                    const y = point.y * canvas.height;
                    
                    // Draw with varied styles for artistic effect
                    if (index % 4 === 0) { // Knuckles
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.beginPath();
                        ctx.arc(x, y, 4, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (index === 8) { // Index fingertip - main interaction point
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                        ctx.beginPath();
                        ctx.arc(x, y, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Add artistic ink splash effect
                        if (isClicking) {
                            const splashRadius = 15;
                            const splashCount = 8;
                            
                            for (let i = 0; i < splashCount; i++) {
                                const angle = (i / splashCount) * Math.PI * 2;
                                const length = splashRadius * (0.7 + Math.random() * 0.5);
                                
                                ctx.beginPath();
                                ctx.moveTo(x, y);
                                ctx.lineTo(
                                    x + Math.cos(angle) * length,
                                    y + Math.sin(angle) * length
                                );
                                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                                ctx.lineWidth = 1 + Math.random();
                                ctx.stroke();
                            }
                        }
                    } else { // Regular points
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
            }
            
            ctx.restore();
        }
        
        // Handle window resize
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Recalculate grid size on resize
            // Could rebuild the grid here if needed
        });
        
        // Initialize and start animation
        function init() {
            createPrismGrid();
            animate(0);
        }
        
        // Create small clone prisms that orbit the original
        function createPrismClones(parentPrism) {
            // Create 2-4 clones
            const cloneCount = 2 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < cloneCount; i++) {
                // Calculate position on orbit around parent
                const angle = (i / cloneCount) * Math.PI * 2;
                const orbitRadius = parentPrism.size * 2;
                const orbitX = parentPrism.x + Math.cos(angle) * orbitRadius;
                const orbitY = parentPrism.y + Math.sin(angle) * orbitRadius;
                
                // Create a clone with similar properties but smaller
                const clone = {
                    parentPrism: parentPrism,
                    x: parentPrism.x, // Start at parent position
                    y: parentPrism.y,
                    targetX: orbitX, // Target orbit position
                    targetY: orbitY,
                    type: parentPrism.type,
                    size: parentPrism.size * (0.3 + Math.random() * 0.2), // 30-50% of original size
                    rotation: parentPrism.rotation,
                    rotationSpeed: parentPrism.rotationSpeed * 2, // Rotate faster
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: parentPrism.pulseSpeed * 1.5, // Pulse faster
                    lightLevel: 0.8 + Math.random() * 0.2, // Start brighter
                    lineThickness: parentPrism.lineThickness * 0.8,
                    zOffset: parentPrism.zOffset,
                    color: {...parentPrism.color},
                    orbitAngle: angle,
                    orbitSpeed: 0.2 + Math.random() * 0.3,
                    orbitRadius: orbitRadius,
                    orbitPhase: Math.random() * Math.PI * 2,
                    birthTime: time,
                    lifespan: 15 + Math.random() * 10 // Live for 15-25 seconds
                };
                
                // Add to clones array
                prismClones.push(clone);
                
                // Create emergence particles for visual effect
                createEmergenceEffect(clone);
            }
        }
        
        // Create particles that show a clone emerging
        function createEmergenceEffect(clone) {
            const particleCount = 10 + Math.floor(Math.random() * 8);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 30 + Math.random() * 40;
                
                // Create particle with same color as parent but brighter
                const r = clone.color.r + 100;
                const g = clone.color.g + 100;
                const b = clone.color.b + 100;
                
                particles.push({
                    x: clone.x,
                    y: clone.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3,
                    color: { r, g, b },
                    alpha: 0.7 + Math.random() * 0.3,
                    life: 1.0,
                    decay: 0.05 + Math.random() * 0.05,
                    inkDrop: false
                });
                
                // Limit max particles
                if (particles.length > maxParticles) {
                    particles.shift();
                }
            }
        }
        
        // Create light bridges connecting to other activated prisms
        function createLightBridges(prism) {
            // Find other activated prisms to connect to
            for (let otherPrism of prisms) {
                // Skip self or non-activated prisms
                if (otherPrism === prism || !otherPrism.activated || otherPrism.activationProgress < 0.5) {
                    continue;
                }
                
                // Calculate distance
                const dx = otherPrism.x - prism.x;
                const dy = otherPrism.y - prism.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Only connect if within reasonable distance
                if (distance < 500) {
                    // Check if connection already exists
                    let connectionExists = false;
                    for (let conn of connections) {
                        if ((conn.from === prism && conn.to === otherPrism) ||
                            (conn.from === otherPrism && conn.to === prism)) {
                            connectionExists = true;
                            break;
                        }
                    }
                    
                    // Create new connection if it doesn't exist
                    if (!connectionExists) {
                        // Random connection properties
                        const pulseSpeed = 0.5 + Math.random();
                        const thickness = 1 + Math.random() * 2;
                        const pathAmplitude = 5 + Math.random() * 15; // Wiggle amount
                        
                        // Create connection beam
                        connections.push({
                            from: prism,
                            to: otherPrism,
                            startTime: time,
                            progress: 0, // Grows from 0 to 1
                            pulsePhase: Math.random() * Math.PI * 2,
                            pulseSpeed: pulseSpeed,
                            pathPoints: [], // Will store points for beam path
                            thickness: thickness,
                            pathSegments: 12, // Number of segments in the beam path
                            pathAmplitude: pathAmplitude,
                            pathFrequency: 1 + Math.random() * 2,
                            color: {
                                r: (prism.color.r + otherPrism.color.r) / 2,
                                g: (prism.color.g + otherPrism.color.g) / 2,
                                b: (prism.color.b + otherPrism.color.b) / 2
                            },
                            energy: 1.0 // Initial energy level
                        });
                        
                        // Limit max connections
                        if (connections.length > maxConnections) {
                            connections.shift();
                        }
                        
                        // Create particles along the connection path
                        createConnectionParticles(connections[connections.length - 1]);
                        
                        // If we have enough connections, sometimes create light beam bridges
                        if (connections.length > 5 && Math.random() > 0.7) {
                            createLightBeam(prism);
                        }
                    }
                }
            }
        }
        
        // Create particles along a new connection
        function createConnectionParticles(connection) {
            const particleCount = 15 + Math.floor(Math.random() * 10);
            const fromX = connection.from.x;
            const fromY = connection.from.y;
            const toX = connection.to.x;
            const toY = connection.to.y;
            
            for (let i = 0; i < particleCount; i++) {
                const t = Math.random(); // Position along line
                const x = fromX + (toX - fromX) * t;
                const y = fromY + (toY - fromY) * t;
                
                // Direction along the line
                const angle = Math.atan2(toY - fromY, toX - fromX);
                // Speed varies based on position - faster in the middle
                const speed = 30 + Math.abs(t - 0.5) * 60;
                
                // Create particle with connection color
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 1 + Math.random() * 2,
                    color: connection.color,
                    alpha: 0.7 + Math.random() * 0.3,
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.1 + Math.random() * 0.1,
                    inkDrop: false
                });
                
                // Limit max particles
                if (particles.length > maxParticles) {
                    particles.shift();
                }
            }
        }
        
        // Create laser-like light beams
        function createLightBeam(sourcePrism) {
            // Choose a beam angle - either radiate outward from center or random
            let angle;
            if (Math.random() > 0.5) {
                // Radiate from center of canvas
                const toCenterX = canvas.width / 2 - sourcePrism.x;
                const toCenterY = canvas.height / 2 - sourcePrism.y;
                angle = Math.atan2(toCenterY, toCenterX) + (Math.random() - 0.5) * 1.0;
            } else {
                // Random angle
                angle = Math.random() * Math.PI * 2;
            }
            
            // Beam properties
            const length = 400 + Math.random() * 600;
            const thickness = 1 + Math.random() * 3;
            
            lightBeams.push({
                x: sourcePrism.x,
                y: sourcePrism.y,
                angle: angle,
                length: length,
                thickness: thickness,
                pulsePhase: Math.random() * Math.PI * 2,
                pulseSpeed: 1 + Math.random() * 2,
                startTime: time,
                lifespan: 8 + Math.random() * 5,
                color: {...sourcePrism.color},
                segments: 1 + Math.floor(Math.random() * 3), // Beam can have multiple segments
                segmentAngles: [], // Initialize segment angles
                energy: 1.0
            });
            
            // Calculate segment angles
            const beam = lightBeams[lightBeams.length - 1];
            
            beam.segmentAngles.push(angle); // First segment uses main angle
            for (let i = 1; i < beam.segments; i++) {
                // Each additional segment deviates slightly from previous
                beam.segmentAngles.push(beam.segmentAngles[i-1] + (Math.random() - 0.5) * 0.7);
            }
            
            // Create beam creation effect
            createBeamEffect(beam);
        }
        
        // Create visual effect when a beam is created
        function createBeamEffect(beam) {
            // Calculate endpoint of first segment
            const segLength = beam.length / beam.segments;
            const endX = beam.x + Math.cos(beam.angle) * segLength;
            const endY = beam.y + Math.sin(beam.angle) * segLength;
            
            // Create particles along the beam
            const particleCount = 20 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < particleCount; i++) {
                const t = Math.random(); // Position along beam
                const x = beam.x + (endX - beam.x) * t;
                const y = beam.y + (endY - beam.y) * t;
                
                // Calculate particle velocity - perpendicular to beam with random direction
                const perpAngle = beam.angle + Math.PI/2 * (Math.random() > 0.5 ? 1 : -1);
                const speed = 30 + Math.random() * 50;
                
                // Create particle with beam color but brighter
                const r = Math.min(255, beam.color.r + 100);
                const g = Math.min(255, beam.color.g + 100);
                const b = Math.min(255, beam.color.b + 100);
                
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(perpAngle) * speed,
                    vy: Math.sin(perpAngle) * speed,
                    size: 1 + Math.random() * 3,
                    color: { r, g, b },
                    alpha: 0.8 + Math.random() * 0.2,
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.05 + Math.random() * 0.05,
                    inkDrop: false
                });
                
                // Limit max particles
                if (particles.length > maxParticles) {
                    particles.shift();
                }
            }
        }
        
        // Add energy pulse to the network through an activated prism
        function energizeLightNetwork(prism) {
            // Create energy pulse visuals
            createEnergyPulse(prism);
            
            // Find connected prisms to energize
            for (let conn of connections) {
                if (conn.from === prism || conn.to === prism) {
                    // Boost connection energy
                    conn.energy = Math.min(2.0, conn.energy + 0.5);
                    
                    // Energize the other prism in the connection
                    const otherPrism = (conn.from === prism) ? conn.to : conn.from;
                    
                    // Schedule an energy pulse with delay
                    setTimeout(() => {
                        if (otherPrism.activated) {
                            createEnergyPulse(otherPrism);
                        }
                    }, 200 + Math.random() * 300);
                }
            }
            
            // Random chance to create new light beam
            if (Math.random() > 0.5) {
                createLightBeam(prism);
            }
        }
        
        // Create visual energy pulse around a prism
        function createEnergyPulse(prism) {
            // Create concentric wave effect
            const waveCount = 2 + Math.floor(Math.random() * 3);
            
            for (let i = 0; i < waveCount; i++) {
                // Energy wave properties
                const wave = {
                    x: prism.x,
                    y: prism.y,
                    radius: prism.size,
                    maxRadius: prism.size * (3 + Math.random() * 2),
                    thickness: 1 + Math.random() * 2,
                    expansionSpeed: 100 + Math.random() * 150,
                    color: {...prism.color},
                    startTime: time + i * 0.1, // Stagger waves
                    alpha: 0.8,
                    type: 'energyWave'
                };
                
                // Add to particles array for updates
                particles.push(wave);
            }
            
            // Also create traditional particles
            const particleCount = 10 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 100;
                
                // Create particle with prism color but brighter
                const r = Math.min(255, prism.color.r + 150);
                const g = Math.min(255, prism.color.g + 150);
                const b = Math.min(255, prism.color.b + 150);
                
                particles.push({
                    x: prism.x,
                    y: prism.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 4,
                    color: { r, g, b },
                    alpha: 0.9,
                    life: 0.5 + Math.random() * 0.3,
                    decay: 0.1 + Math.random() * 0.1,
                    inkDrop: false
                });
            }
            
            // Limit max particles
            while (particles.length > maxParticles) {
                particles.shift();
            }
        }
        
        // Create cracks on a prism surface
        function createCracksOnPrism(prism) {
            // If prism already has cracks, extend them
            let existingCracks = cracks.filter(crack => crack.prism === prism);
            
            if (existingCracks.length > 0) {
                // Extend existing cracks
                for (let crack of existingCracks) {
                    // Add new segments to the crack
                    const extensionCount = 1 + Math.floor(Math.random() * 3);
                    
                    for (let i = 0; i < extensionCount; i++) {
                        // Get last segment point
                        const lastPoint = crack.points[crack.points.length - 1];
                        
                        // Create new crack segment with some deviation
                        const angle = crack.angle + (Math.random() - 0.5) * 1.5;
                        const length = 5 + Math.random() * 10;
                        
                        const newX = lastPoint.x + Math.cos(angle) * length;
                        const newY = lastPoint.y + Math.sin(angle) * length;
                        
                        // Add new point
                        crack.points.push({ x: newX, y: newY });
                        
                        // Update crack properties
                        crack.length += length;
                        crack.severity = Math.min(1.0, crack.severity + 0.1);
                        crack.angle = angle;
                    }
                    
                    // Trigger ichor drops from new crack points
                    if (Math.random() > 0.5) {
                        createIchorDrop(prism, crack.points[crack.points.length - 1]);
                    }
                }
            } else {
                // Create new cracks
                const crackCount = 2 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < crackCount; i++) {
                    // Start angle - random direction from center
                    const angle = Math.random() * Math.PI * 2;
                    
                    // Create a new crack with initial segment
                    const initialLength = 5 + Math.random() * 15;
                    const startX = Math.cos(angle) * prism.size * 0.5; // Start inside the prism
                    const startY = Math.sin(angle) * prism.size * 0.5;
                    const endX = startX + Math.cos(angle) * initialLength;
                    const endY = startY + Math.sin(angle) * initialLength;
                    
                    cracks.push({
                        prism: prism,
                        points: [{ x: startX, y: startY }, { x: endX, y: endY }],
                        angle: angle,
                        length: initialLength,
                        width: 0.5 + Math.random() * 1.5,
                        creationTime: time,
                        severity: 0.2 + Math.random() * 0.3, // Initial severity
                        pulsePhase: Math.random() * Math.PI * 2
                    });
                    
                    // Reduce prism's light level to show damage
                    prism.lightLevel = Math.max(0.1, prism.lightLevel - 0.15);
                    
                    // Create some ichor drops from cracks
                    if (Math.random() > 0.3) {
                        createIchorDrop(prism, { x: endX, y: endY });
                    }
                }
            }
        }
        
        // Create a drop of black ichor leaking from a crack
        function createIchorDrop(prism, crackPoint) {
            // Convert to global coordinates
            const globalX = prism.x + crackPoint.x;
            const globalY = prism.y + crackPoint.y;
            
            // Create ichor drop with initial velocity down
            ichorDrops.push({
                x: globalX,
                y: globalY,
                size: 2 + Math.random() * 4,
                vx: (Math.random() - 0.5) * 10, // Some horizontal drift
                vy: 30 + Math.random() * 40, // Downward velocity
                opacity: 0.7 + Math.random() * 0.3,
                decay: 0.005 + Math.random() * 0.01, // Slow decay
                creationTime: time,
                trail: [], // Will hold trail points
                maxTrailLength: 10 + Math.floor(Math.random() * 10)
            });
            
            // Create shatter particles
            const particleCount = 5 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 40 + Math.random() * 60;
                
                particles.push({
                    x: globalX,
                    y: globalY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 1 + Math.random() * 2,
                    color: { r: 50, g: 50, b: 70 },
                    alpha: 0.7 + Math.random() * 0.3,
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.05 + Math.random() * 0.1,
                    inkDrop: true
                });
            }
        }
        
        // Create a visual effect of black ichor
        function createIchorEffect(prism) {
            // Create a burst of dark particles
            const particleCount = 15 + Math.floor(Math.random() * 15);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 30 + Math.random() * 70;
                
                particles.push({
                    x: prism.x,
                    y: prism.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 3 + Math.random() * 4,
                    color: { r: 10, g: 10, b: 25 },
                    alpha: 0.8 + Math.random() * 0.2,
                    life: 0.7 + Math.random() * 0.5,
                    decay: 0.03 + Math.random() * 0.05,
                    inkDrop: true
                });
            }
            
            // Large ink splatter
            createInkSplatter(
                handPosition.x, 
                handPosition.y, 
                false  // Not small
            );
        }
        
        // Create a reflection pool showing distorted versions of previous scenes
        function createReflectionPool(prism) {
            // Check if there's already a reflection near this prism
            for (let pool of reflectionPools) {
                const dx = pool.x - prism.x;
                const dy = pool.y - prism.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < pool.size + prism.size) {
                    // Just expand the existing pool
                    pool.size = Math.min(150, pool.size + 20);
                    pool.intensity = Math.min(1.0, pool.intensity + 0.2);
                    pool.lastUpdateTime = time;
                    return;
                }
            }
            
            // Create a new reflection pool
            reflectionPools.push({
                x: prism.x,
                y: prism.y,
                size: 40 + Math.random() * 30,
                rotation: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.05,
                distortionPhase: Math.random() * Math.PI * 2,
                distortionFrequency: 1 + Math.random() * 3,
                distortionAmplitude: 5 + Math.random() * 15,
                intensity: 0.3 + Math.random() * 0.3,
                pulsePhase: Math.random() * Math.PI * 2,
                creationTime: time,
                lastUpdateTime: time,
                // Properties for the distorted "reality" shown in reflection
                imageType: Math.random() > 0.5 ? 'coral' : 'diamond',
                colorShift: Math.random() * Math.PI * 2
            });
        }
        
        // Break connection beams connected to a prism
        function breakConnections(prism) {
            for (let i = connections.length - 1; i >= 0; i--) {
                const conn = connections[i];
                
                if (conn.from === prism || conn.to === prism) {
                    // Create break effect
                    createConnectionBreakEffect(conn);
                    
                    // Remove the connection
                    connections.splice(i, 1);
                }
            }
        }
        
        // Create visual effect when a connection breaks
        function createConnectionBreakEffect(connection) {
            const fromX = connection.from.x;
            const fromY = connection.from.y;
            const toX = connection.to.x;
            const toY = connection.to.y;
            
            // Calculate midpoint
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            
            // Create burst of particles at the break point (midpoint)
            const particleCount = 20 + Math.floor(Math.random() * 20);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 40 + Math.random() * 80;
                
                // Create particle with connection color but more intense
                const r = Math.min(255, connection.color.r + 50);
                const g = Math.min(255, connection.color.g + 50);
                const b = Math.min(255, connection.color.b + 50);
                
                particles.push({
                    x: midX + (Math.random() - 0.5) * 30, // Randomize position along connection
                    y: midY + (Math.random() - 0.5) * 30,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 3,
                    color: { r, g, b },
                    alpha: 0.9,
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.05 + Math.random() * 0.1,
                    inkDrop: false
                });
            }
            
            // Also create some dark particles
            const darkParticleCount = 10 + Math.floor(Math.random() * 10);
            
            for (let i = 0; i < darkParticleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 30 + Math.random() * 50;
                
                particles.push({
                    x: midX + (Math.random() - 0.5) * 30,
                    y: midY + (Math.random() - 0.5) * 30,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 2 + Math.random() * 4,
                    color: { r: 20, g: 20, b: 30 },
                    alpha: 0.8,
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.05 + Math.random() * 0.1,
                    inkDrop: true
                });
            }
        }
        
        // Update and draw prism clones
        function updateAndDrawPrismClones() {
            for (let i = prismClones.length - 1; i >= 0; i--) {
                const clone = prismClones[i];
                
                // Check for expired clones
                if (time - clone.birthTime > clone.lifespan) {
                    // Create dissolution particles
                    createEmergenceEffect(clone);
                    prismClones.splice(i, 1);
                    continue;
                }
                
                // Update the orbit position
                clone.orbitAngle += clone.orbitSpeed * deltaTime;
                
                // Calculate new target position
                const targetX = clone.parentPrism.x + Math.cos(clone.orbitAngle) * clone.orbitRadius;
                const targetY = clone.parentPrism.y + Math.sin(clone.orbitAngle) * clone.orbitRadius;
                
                // Smooth interpolation
                clone.x += (targetX - clone.x) * deltaTime * 2;
                clone.y += (targetY - clone.y) * deltaTime * 2;
                
                // Update rotation
                clone.rotation += clone.rotationSpeed * deltaTime;
                
                // Draw the clone (similar to regular prism but smaller)
                const drawX = clone.x - cameraX;
                const drawY = clone.y - cameraY;
                
                // Skip if offscreen
                if (drawX < -clone.size - 50 || drawX > canvas.width + clone.size + 50 ||
                    drawY < -clone.size - 50 || drawY > canvas.height + clone.size + 50) {
                    continue;
                }
                
                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(clone.rotation);
                
                // Draw based on type
                if (clone.type === 'hexagon') {
                    const pulse = Math.sin(time * clone.pulseSpeed + clone.pulsePhase) * 0.2 + 0.8;
                    drawHexagon(clone, pulse, clone.lightLevel);
                } else {
                    const pulse = Math.sin(time * clone.pulseSpeed + clone.pulsePhase) * 0.2 + 0.8;
                    drawTetrahedron(clone, pulse, clone.lightLevel);
                }
                
                ctx.restore();
                
                // Occasionally emit particles
                if (Math.random() > 0.95) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = clone.size * 0.3;
                    const x = clone.x + Math.cos(angle) * distance;
                    const y = clone.y + Math.sin(angle) * distance;
                    
                    particles.push({
                        x, y,
                        vx: Math.cos(angle) * 10,
                        vy: Math.sin(angle) * 10,
                        size: 1 + Math.random() * 2,
                        color: {...clone.color},
                        alpha: 0.6 + Math.random() * 0.3,
                        life: 0.3 + Math.random() * 0.3,
                        decay: 0.05 + Math.random() * 0.05,
                        inkDrop: false
                    });
                }
            }
        }
        
        // Update and draw light beams
        function updateAndDrawLightBeams() {
            for (let i = lightBeams.length - 1; i >= 0; i--) {
                const beam = lightBeams[i];
                
                // Check for expired beams
                if (time - beam.startTime > beam.lifespan) {
                    lightBeams.splice(i, 1);
                    continue;
                }
                
                // Apply camera offset
                const drawX = beam.x - cameraX;
                const drawY = beam.y - cameraY;
                
                // Skip if origin is far offscreen
                if (drawX < -canvas.width || drawX > canvas.width * 2 ||
                    drawY < -canvas.height || drawY > canvas.height * 2) {
                    continue;
                }
                
                ctx.save();
                
                // Calculate pulse effect
                const pulse = Math.sin(time * beam.pulseSpeed + beam.pulsePhase) * 0.3 + 0.7;
                const age = time - beam.startTime;
                const ageProgress = Math.min(1, age / (beam.lifespan * 0.2));
                
                // Beam starts thin then grows to full width
                const currentThickness = beam.thickness * pulse * ageProgress * beam.energy;
                
                // Draw beam segments
                let currentX = drawX;
                let currentY = drawY;
                const segmentLength = beam.length / beam.segments;
                
                for (let j = 0; j < beam.segments; j++) {
                    const angle = beam.segmentAngles[j];
                    const endX = currentX + Math.cos(angle) * segmentLength;
                    const endY = currentY + Math.sin(angle) * segmentLength;
                    
                    // Draw the beam segment
                    ctx.beginPath();
                    ctx.moveTo(currentX, currentY);
                    ctx.lineTo(endX, endY);
                    
                    // Use beam color with pulse effect
                    const r = beam.color.r;
                    const g = beam.color.g;
                    const b = beam.color.b;
                    
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.6 * pulse * beam.energy})`;
                    ctx.lineWidth = currentThickness;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    
                    // Draw glow effect
                    ctx.globalCompositeOperation = 'screen';
                    ctx.beginPath();
                    ctx.moveTo(currentX, currentY);
                    ctx.lineTo(endX, endY);
                    ctx.strokeStyle = `rgba(${r + 50}, ${g + 50}, ${b + 50}, ${0.3 * pulse * beam.energy})`;
                    ctx.lineWidth = currentThickness * 2;
                    ctx.stroke();
                    
                    // Occasionally emit particles along the beam
                    if (Math.random() > 0.9) {
                        const t = Math.random();
                        const particleX = currentX + (endX - currentX) * t;
                        const particleY = currentY + (endY - currentY) * t;
                        
                        // Direction perpendicular to beam
                        const perpAngle = angle + Math.PI/2;
                        
                        // Create particle
                        particles.push({
                            x: particleX,
                            y: particleY,
                            vx: Math.cos(perpAngle) * (10 + Math.random() * 20),
                            vy: Math.sin(perpAngle) * (10 + Math.random() * 20),
                            size: 1 + Math.random() * 2,
                            color: {...beam.color},
                            alpha: 0.7 * beam.energy,
                            life: 0.3 + Math.random() * 0.2,
                            decay: 0.1 + Math.random() * 0.1,
                            inkDrop: false
                        });
                    }
                    
                    // Update current point for next segment
                    currentX = endX;
                    currentY = endY;
                }
                
                ctx.restore();
                
                // Decay beam energy over time
                beam.energy = Math.max(0.1, beam.energy - deltaTime * 0.1);
            }
        }
        
        // Update and draw connections between prisms
        function updateAndDrawConnections() {
            for (let i = connections.length - 1; i >= 0; i--) {
                const conn = connections[i];
                
                // Check if either prism has been removed/destroyed
                if (!prisms.includes(conn.from) || !prisms.includes(conn.to)) {
                    connections.splice(i, 1);
                    continue;
                }
                
                // Update connection progress (grows from 0 to 1)
                conn.progress = Math.min(1, conn.progress + deltaTime * 0.5);
                
                // Calculate endpoints
                const fromX = conn.from.x - cameraX;
                const fromY = conn.from.y - cameraY;
                const toX = conn.to.x - cameraX;
                const toY = conn.to.y - cameraY;
                
                // Skip if connection is completely offscreen
                if ((fromX < -100 && toX < -100) || (fromX > canvas.width + 100 && toX > canvas.width + 100) ||
                    (fromY < -100 && toY < -100) || (fromY > canvas.height + 100 && toY > canvas.height + 100)) {
                    continue;
                }
                
                // Calculate current progress length
                const fullDx = toX - fromX;
                const fullDy = toY - fromY;
                const currentToX = fromX + fullDx * conn.progress;
                const currentToY = fromY + fullDy * conn.progress;
                
                // Regenerate path points if needed
                if (conn.pathPoints.length === 0 || time - conn.startTime > 5) {
                    // Generate a slightly curved path between the two points
                    conn.pathPoints = [];
                    const segments = conn.pathSegments;
                    
                    for (let j = 0; j <= segments; j++) {
                        const t = j / segments;
                        
                        // Midpoint with offset
                        const midX = fromX + fullDx * 0.5;
                        const midY = fromY + fullDy * 0.5;
                        
                        // Calculate perpendicular vector for offset
                        const perpX = -fullDy;
                        const perpY = fullDx;
                        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                        
                        // Normalized perpendicular vector
                        const normPerpX = perpX / perpLength;
                        const normPerpY = perpY / perpLength;
                        
                        // Sinusoidal offset for natural curve
                        const wavePhase = time * conn.pathFrequency + conn.pulsePhase;
                        const offset = Math.sin(t * Math.PI + wavePhase) * conn.pathAmplitude;
                        
                        // Calculate point with offset
                        const x = fromX + fullDx * t + normPerpX * offset;
                        const y = fromY + fullDy * t + normPerpY * offset;
                        
                        conn.pathPoints.push({ x, y });
                    }
                    
                    // Reset start time
                    conn.startTime = time;
                }
                
                // Calculate pulse effect
                const pulse = Math.sin(time * conn.pulseSpeed + conn.pulsePhase) * 0.3 + 0.7;
                
                // Current thickness with pulse
                const thickness = conn.thickness * pulse * conn.energy;
                
                ctx.save();
                
                // Draw the path up to current progress
                ctx.beginPath();
                
                // Color varies based on overload state
                let r, g, b;
                
                if (overloadProgress > 0) {
                    // Transition from normal color to blood-red as overload increases
                    // Base connection color
                    const baseR = conn.color.r;
                    const baseG = conn.color.g;
                    const baseB = conn.color.b;
                    
                    // Blood-red target color
                    const targetR = 200;
                    const targetG = 0;
                    const targetB = 20;
                    
                    // Interpolate between base and target
                    r = Math.round(baseR + (targetR - baseR) * overloadProgress);
                    g = Math.round(baseG + (targetG - baseG) * overloadProgress);
                    b = Math.round(baseB + (targetB - baseB) * overloadProgress);
                    
                    // Add pulsing effect during overload
                    if (overloadProgress > 0.5) {
                        const overloadPulse = Math.sin(time * 10) * 0.5 + 0.5;
                        r += Math.round(overloadPulse * 55);
                    }
                } else {
                    r = conn.color.r;
                    g = conn.color.g;
                    b = conn.color.b;
                }
                
                // Draw only up to current progress
                const progressIndex = Math.floor(conn.pathPoints.length * conn.progress);
                
                if (progressIndex > 0) {
                    ctx.moveTo(conn.pathPoints[0].x, conn.pathPoints[0].y);
                    
                    for (let j = 1; j <= progressIndex; j++) {
                        if (j < conn.pathPoints.length) {
                            ctx.lineTo(conn.pathPoints[j].x, conn.pathPoints[j].y);
                        }
                    }
                    
                    // Draw the connection
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.7 * pulse * conn.energy})`;
                    ctx.lineWidth = thickness;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    
                    // Add glow effect
                    ctx.globalCompositeOperation = 'screen';
                    ctx.beginPath();
                    
                    ctx.moveTo(conn.pathPoints[0].x, conn.pathPoints[0].y);
                    for (let j = 1; j <= progressIndex; j++) {
                        if (j < conn.pathPoints.length) {
                            ctx.lineTo(conn.pathPoints[j].x, conn.pathPoints[j].y);
                        }
                    }
                    
                    // Glow color also shifts during overload
                    const glowR = Math.min(255, r + 30 + (overloadProgress * 50));
                    const glowG = Math.min(255, g + 30 - (overloadProgress * 30));
                    const glowB = Math.min(255, b + 30 - (overloadProgress * 30));
                    
                    ctx.strokeStyle = `rgba(${glowR}, ${glowG}, ${glowB}, ${0.3 * pulse * conn.energy})`;
                    ctx.lineWidth = thickness * 2;
                    ctx.stroke();
                }
                
                ctx.restore();
                
                // Occasionally emit particles along the connection
                if (conn.progress >= 1 && Math.random() > 0.95) {
                    const particleIndex = Math.floor(Math.random() * conn.pathPoints.length);
                    if (particleIndex < conn.pathPoints.length) {
                        const particlePoint = conn.pathPoints[particleIndex];
                        
                        particles.push({
                            x: particlePoint.x + cameraX,
                            y: particlePoint.y + cameraY,
                            vx: (Math.random() - 0.5) * 20,
                            vy: (Math.random() - 0.5) * 20,
                            size: 1 + Math.random() * 2,
                            color: {r, g, b},
                            alpha: 0.7 * conn.energy,
                            life: 0.3 + Math.random() * 0.2,
                            decay: 0.1 + Math.random() * 0.1,
                            inkDrop: false
                        });
                    }
                }
                
                // During overload, connections emit more particles and visual artifacts
                if (overloadProgress > 0.5 && Math.random() > 0.95) {
                    // Randomly pick a point on the connection
                    const particleIndex = Math.floor(Math.random() * conn.pathPoints.length);
                    if (particleIndex < conn.pathPoints.length) {
                        const point = conn.pathPoints[particleIndex];
                        
                        // Create "data corruption" effect particles
                        const corruptionCount = 3 + Math.floor(Math.random() * 5);
                        
                        for (let k = 0; k < corruptionCount; k++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 50 + Math.random() * 100;
                            
                            particles.push({
                                x: point.x + cameraX,
                                y: point.y + cameraY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                size: 2 + Math.random() * 3,
                                color: { r: 255, g: 0, b: 50 },
                                alpha: 0.8,
                                life: 0.3 + Math.random() * 0.3,
                                decay: 0.1 + Math.random() * 0.1,
                                inkDrop: false,
                                isGlitch: true
                            });
                        }
                    }
                }
                
                // Gradual energy decay (unless recently energized)
                conn.energy = Math.max(0.2, conn.energy - deltaTime * 0.05);
            }
        }
        
        // Draw cracks on prisms
        function drawCracks() {
            // First group cracks by prism for efficiency
            const cracksByPrism = {};
            
            for (let crack of cracks) {
                const prismId = prisms.indexOf(crack.prism);
                if (prismId !== -1) {
                    if (!cracksByPrism[prismId]) {
                        cracksByPrism[prismId] = [];
                    }
                    cracksByPrism[prismId].push(crack);
                }
            }
            
            // Draw cracks for each prism
            for (let prismId in cracksByPrism) {
                const prism = prisms[prismId];
                const prismCracks = cracksByPrism[prismId];
                
                // Skip if prism is offscreen
                const drawX = prism.x - cameraX;
                const drawY = prism.y - cameraY;
                
                if (drawX < -prism.size - 100 || drawX > canvas.width + prism.size + 100 ||
                    drawY < -prism.size - 100 || drawY > canvas.height + prism.size + 100) {
                    continue;
                }
                
                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(prism.rotation);
                
                // Draw each crack
                for (let crack of prismCracks) {
                    if (crack.points.length < 2) continue;
                    
                    // Calculate pulse/shimmer effect
                    const pulse = Math.sin(time * 2 + crack.pulsePhase) * 0.3 + 0.7;
                    
                    // Draw the crack path
                    ctx.beginPath();
                    ctx.moveTo(crack.points[0].x, crack.points[0].y);
                    
                    for (let i = 1; i < crack.points.length; i++) {
                        ctx.lineTo(crack.points[i].x, crack.points[i].y);
                    }
                    
                    // Black ink style with slight transparency
                    ctx.strokeStyle = `rgba(0, 0, 0, ${0.7 * crack.severity * pulse})`;
                    ctx.lineWidth = crack.width;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    
                    // Add subtle secondary line for depth
                    ctx.beginPath();
                    ctx.moveTo(crack.points[0].x, crack.points[0].y);
                    
                    for (let i = 1; i < crack.points.length; i++) {
                        ctx.lineTo(crack.points[i].x, crack.points[i].y);
                    }
                    
                    ctx.strokeStyle = `rgba(40, 40, 60, ${0.3 * crack.severity * pulse})`;
                    ctx.lineWidth = crack.width * 0.6;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }
        
        // Update and draw ichor drops
        function updateAndDrawIchorDrops() {
            for (let i = ichorDrops.length - 1; i >= 0; i--) {
                const drop = ichorDrops[i];
                
                // Apply gravity
                drop.vy += 30 * deltaTime; // Acceleration
                
                // Update position
                drop.x += drop.vx * deltaTime;
                drop.y += drop.vy * deltaTime;
                
                // Add point to trail
                drop.trail.push({ x: drop.x, y: drop.y });
                
                // Limit trail length
                if (drop.trail.length > drop.maxTrailLength) {
                    drop.trail.shift();
                }
                
                // Remove if off screen or too old
                if (drop.y > canvas.height + 100 || 
                    drop.opacity <= 0.1 || 
                    time - drop.creationTime > 10) {
                    ichorDrops.splice(i, 1);
                    continue;
                }
                
                // Fade out over time
                drop.opacity -= drop.decay * deltaTime;
                
                // Apply camera offset
                const drawX = drop.x - cameraX;
                const drawY = drop.y - cameraY;
                
                // Skip if offscreen
                if (drawX < -50 || drawX > canvas.width + 50 ||
                    drawY < -50 || drawY > canvas.height + 50) {
                    continue;
                }
                
                // Draw trail
                if (drop.trail.length > 1) {
                    ctx.save();
                    
                    ctx.beginPath();
                    
                    // Start with oldest trail point
                    ctx.moveTo(
                        drop.trail[0].x - cameraX,
                        drop.trail[0].y - cameraY
                    );
                    
                    // Connect all points
                    for (let j = 1; j < drop.trail.length; j++) {
                        ctx.lineTo(
                            drop.trail[j].x - cameraX,
                            drop.trail[j].y - cameraY
                        );
                    }
                    
                    // Create gradient for trail
                    const gradient = ctx.createLinearGradient(
                        drop.trail[0].x - cameraX,
                        drop.trail[0].y - cameraY,
                        drawX,
                        drawY
                    );
                    
                    gradient.addColorStop(0, `rgba(0, 0, 0, 0)`);
                    gradient.addColorStop(1, `rgba(0, 0, 0, ${drop.opacity * 0.5})`);
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = drop.size * 0.6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    
                    ctx.restore();
                }
                
                // Draw drop
                ctx.beginPath();
                ctx.arc(drawX, drawY, drop.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 0, 0, ${drop.opacity})`;
                ctx.fill();
                
                // Draw highlight on drop
                ctx.beginPath();
                ctx.arc(
                    drawX - drop.size * 0.3,
                    drawY - drop.size * 0.3,
                    drop.size * 0.3,
                    0,
                    Math.PI * 2
                );
                ctx.fillStyle = `rgba(60, 60, 80, ${drop.opacity * 0.5})`;
                ctx.fill();
            }
        }
        
        // Update and draw reflection pools
        function updateAndDrawReflectionPools() {
            for (let i = reflectionPools.length - 1; i >= 0; i--) {
                const pool = reflectionPools[i];
                
                // Update rotation
                pool.rotation += pool.rotationSpeed * deltaTime;
                
                // Fade out old pools
                if (time - pool.lastUpdateTime > 20) {
                    pool.intensity -= deltaTime * 0.05;
                    
                    if (pool.intensity <= 0) {
                        reflectionPools.splice(i, 1);
                        continue;
                    }
                }
                
                // Apply camera offset
                const drawX = pool.x - cameraX;
                const drawY = pool.y - cameraY;
                
                // Skip if offscreen
                if (drawX < -pool.size || drawX > canvas.width + pool.size ||
                    drawY < -pool.size || drawY > canvas.height + pool.size) {
                    continue;
                }
                
                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(pool.rotation);
                
                // Distorted effect
                const pulse = Math.sin(time * 0.5 + pool.pulsePhase) * 0.2 + 0.8;
                
                // Draw pool base
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, pool.size);
                gradient.addColorStop(0, `rgba(20, 20, 30, ${0.4 * pool.intensity * pulse})`);
                gradient.addColorStop(0.7, `rgba(30, 30, 50, ${0.3 * pool.intensity * pulse})`);
                gradient.addColorStop(1, `rgba(40, 40, 60, 0)`);
                
                ctx.beginPath();
                ctx.arc(0, 0, pool.size, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Draw ripples
                const rippleCount = 3;
                for (let j = 0; j < rippleCount; j++) {
                    const rippleProgress = ((time * 0.3) + (j / rippleCount)) % 1.0;
                    const rippleRadius = pool.size * rippleProgress;
                    
                    if (rippleRadius > 0 && rippleRadius < pool.size) {
                        ctx.beginPath();
                        ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
                        ctx.strokeStyle = `rgba(40, 40, 70, ${(1 - rippleProgress) * 0.2 * pool.intensity})`;
                        ctx.lineWidth = 1 + Math.sin(rippleProgress * Math.PI) * 2;
                        ctx.stroke();
                    }
                }
                
                // Draw distorted image of previous scenes
                if (pool.imageType === 'coral') {
                    // Draw coral-like structures (mimicking scene 2)
                    const branchCount = 5 + Math.floor(pool.size / 10);
                    
                    for (let j = 0; j < branchCount; j++) {
                        const angle = (j / branchCount) * Math.PI * 2;
                        const length = pool.size * 0.5 * (0.5 + Math.sin(time * 0.2 + j) * 0.2);
                        
                        // Distorted angle
                        const distortion = Math.sin(time * pool.distortionFrequency + angle) * 
                                           pool.distortionAmplitude / 100;
                        
                        const distortedAngle = angle + distortion;
                        
                        const endX = Math.cos(distortedAngle) * length;
                        const endY = Math.sin(distortedAngle) * length;
                        
                        // Color that shifts over time
                        const r = Math.floor(127 + 127 * Math.sin(pool.colorShift + time * 0.3));
                        const g = Math.floor(127 + 127 * Math.sin(pool.colorShift + time * 0.3 + Math.PI * 2/3));
                        const b = Math.floor(127 + 127 * Math.sin(pool.colorShift + time * 0.3 + Math.PI * 4/3));
                        
                        // Draw distorted branch
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.3 * pool.intensity})`;
                        ctx.lineWidth = 2 + Math.sin(time + j) * 1;
                        ctx.stroke();
                        
                        // Draw nodes
                        ctx.beginPath();
                        ctx.arc(endX, endY, 3 + Math.sin(time * 2 + j) * 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.4 * pool.intensity})`;
                        ctx.fill();
                    }
                } else {
                    // Draw diamond-like structures (mimicking scene 1)
                    const sides = 4;
                    const size = pool.size * 0.6;
                    
                    // Distorted diamond
                    ctx.beginPath();
                    for (let j = 0; j <= sides; j++) {
                        const angle = (j / sides) * Math.PI * 2;
                        
                        // Distorted angle
                        const distortion = Math.sin(time * pool.distortionFrequency + angle) * 
                                           pool.distortionAmplitude / 50;
                        
                        const distortedAngle = angle + distortion;
                        
                        // Distorted radius
                        const radiusDistortion = Math.sin(time * 0.5 + angle * 3) * 0.2 + 0.8;
                        const radius = size * radiusDistortion;
                        
                        const x = Math.cos(distortedAngle) * radius;
                        const y = Math.sin(distortedAngle) * radius;
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    // Color that shifts over time
                    const r = Math.floor(127 + 127 * Math.sin(pool.colorShift + time * 0.3));
                    const g = Math.floor(127 + 127 * Math.sin(pool.colorShift + time * 0.3 + Math.PI * 2/3));
                    const b = Math.floor(127 + 127 * Math.sin(pool.colorShift + time * 0.3 + Math.PI * 4/3));
                    
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.3 * pool.intensity})`;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Fill with lower opacity
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${0.1 * pool.intensity})`;
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }
        
        // Trigger the portal transition sequence
        function triggerPortalTransition() {
            // Initialize portal transition state
            portalTransition.active = true;
            portalTransition.progress = 0;
            portalTransition.startTime = time;
            portalTransition.flashProgress = 0;
            portalTransition.portalSize = 0;
            portalTransition.portalRotation = 0;
            portalTransition.lightParticles = [];
            
            // Count activated prisms for portal size scaling
            const activatedPrismCount = prisms.filter(p => p.activated).length;
            portalTransition.isDramatic = activatedPrismCount > 6;
            portalTransition.portalSizeMultiplier = portalTransition.isDramatic ? 2.5 : 1;
            
            // Create light particles from all activated prisms
            for (let prism of prisms) {
                if (prism.activated) {
                    const particleCount = 15 + Math.floor(Math.random() * 10);
                    
                    for (let i = 0; i < particleCount; i++) {
                        portalTransition.lightParticles.push({
                            x: prism.x,
                            y: prism.y,
                            originalX: prism.x,
                            originalY: prism.y,
                            targetX: canvas.width / 2,
                            targetY: canvas.height / 2,
                            size: 3 + Math.random() * 5,
                            speed: 0.5 + Math.random() * 1.5,
                            delay: Math.random() * 0.5,
                            progress: 0,
                            rotation: Math.random() * Math.PI * 2,
                            rotationSpeed: (Math.random() - 0.5) * 0.2,
                            color: {...prism.color},
                            alpha: 0.7 + Math.random() * 0.3,
                            shape: Math.random() > 0.5 ? 'hexagon' : 'tetrahedron'
                        });
                    }
                    
                    // Dim the prism light
                    prism.lightLevel = 0.1;
                }
            }
            
            // If dramatic portal (many prisms activated), add extra visual effects
            if (portalTransition.isDramatic) {
                // Create extra particles for more dramatic effect
                const extraParticleCount = 100 + Math.floor(Math.random() * 50);
                for (let i = 0; i < extraParticleCount; i++) {
                    // Create particles from random screen edges
                    let x, y;
                    if (Math.random() > 0.5) {
                        // From sides
                        x = Math.random() > 0.5 ? -50 : canvas.width + 50;
                        y = Math.random() * canvas.height;
                    } else {
                        // From top/bottom
                        x = Math.random() * canvas.width;
                        y = Math.random() > 0.5 ? -50 : canvas.height + 50;
                    }
                    
                    // Random colors from a dramatic palette
                    const colorSet = [
                        {r: 255, g: 200, b: 100}, // Gold
                        {r: 100, g: 200, b: 255}, // Sky blue
                        {r: 255, g: 100, b: 200}, // Pink
                        {r: 200, g: 255, b: 200}, // Mint
                        {r: 180, g: 130, b: 255}  // Purple
                    ];
                    const color = colorSet[Math.floor(Math.random() * colorSet.length)];
                    
                    portalTransition.lightParticles.push({
                        x: x,
                        y: y,
                        originalX: x,
                        originalY: y,
                        targetX: canvas.width / 2,
                        targetY: canvas.height / 2,
                        size: 3 + Math.random() * 7,
                        speed: 0.3 + Math.random() * 1.0,
                        delay: 0.2 + Math.random() * 1.0,
                        progress: 0,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        color: color,
                        alpha: 0.7 + Math.random() * 0.3,
                        shape: Math.random() > 0.5 ? 'hexagon' : 'tetrahedron',
                        isDramatic: true
                    });
                }
            }
        }
        
        // Update and draw the portal transition sequence
        function updateAndDrawPortalTransition() {
            // Update progress
            portalTransition.progress += deltaTime * 0.4; // Control speed of transition
            
            // Flash effect at the beginning
            if (portalTransition.progress < 0.3) {
                portalTransition.flashProgress = Math.min(1, portalTransition.flashProgress + deltaTime * 4);
                
                // Draw white flash overlay
                const flashOpacity = Math.sin(portalTransition.flashProgress * Math.PI) * 0.7;
                ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else if (portalTransition.flashProgress > 0) {
                portalTransition.flashProgress = Math.max(0, portalTransition.flashProgress - deltaTime * 2);
                
                // Draw fading flash overlay
                const flashOpacity = Math.sin(portalTransition.flashProgress * Math.PI) * 0.7;
                ctx.fillStyle = `rgba(255, 255, 255, ${flashOpacity})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Update and draw light particles
            updateAndDrawLightParticles();
            
            // After particles converge, form the portal
            if (portalTransition.progress > 1.0) {
                // Calculate base target size
                const baseSize = Math.min(canvas.width, canvas.height) * 0.3;
                
                // Apply size multiplier for dramatic portal
                const targetSize = baseSize * portalTransition.portalSizeMultiplier;
                
                // Increase portal size
                portalTransition.portalSize += (targetSize - portalTransition.portalSize) * deltaTime * 2;
                portalTransition.portalRotation += deltaTime * 0.3;
                
                // Draw portal
                drawPortal();
                
                // If portal is almost full size, transition to next scene
                if (!redirectInitiated && portalTransition.portalSize > targetSize * 0.9 && portalTransition.progress > 2.0) {
                    // Mark that redirect has been initiated (both flags for redundancy)
                    window.redirectInProgress = true;
                    redirectInitiated = true;
                    
                    // Prevent multiple redirects
                    portalTransition.progress = 100;
                    
                    // Immediate redirect - no setTimeout delays
                    safeRedirect();
                }
            }
        }
        
        // Update and draw light particles converging to the center
        function updateAndDrawLightParticles() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            for (let particle of portalTransition.lightParticles) {
                // Delay start of some particles
                if (portalTransition.progress < particle.delay) continue;
                
                // Update progress
                particle.progress = Math.min(1, particle.progress + deltaTime * particle.speed);
                
                // Update position - easing curve for natural movement
                const t = easeInOutCubic(particle.progress);
                particle.x = particle.originalX + (centerX - particle.originalX) * t;
                particle.y = particle.originalY + (centerY - particle.originalY) * t;
                
                // Update rotation
                particle.rotation += particle.rotationSpeed;
                
                // Apply camera offset
                const drawX = particle.x - cameraX;
                const drawY = particle.y - cameraY;
                
                // Skip if offscreen
                if (drawX < -50 || drawX > canvas.width + 50 ||
                    drawY < -50 || drawY > canvas.height + 50) {
                    continue;
                }
                
                // Draw particle
                ctx.save();
                ctx.translate(drawX, drawY);
                ctx.rotate(particle.rotation);
                
                // Size decreases slightly as it approaches center
                const currentSize = particle.size * (1 - t * 0.3);
                
                // Draw based on shape
                if (particle.shape === 'hexagon') {
                    drawLightParticleHexagon(particle, currentSize);
                } else {
                    drawLightParticleTetrahedron(particle, currentSize);
                }
                
                ctx.restore();
                
                // Add trails
                if (Math.random() > 0.8) {
                    const trailSize = currentSize * 0.7;
                    const trailAngle = Math.atan2(centerY - particle.originalY, centerX - particle.originalX);
                    const trailX = particle.x - Math.cos(trailAngle) * (10 + Math.random() * 20) * (1 - t);
                    const trailY = particle.y - Math.sin(trailAngle) * (10 + Math.random() * 20) * (1 - t);
                    
                    // Add to regular particles array for easier management
                    particles.push({
                        x: trailX,
                        y: trailY,
                        vx: 0,
                        vy: 0,
                        size: trailSize,
                        color: particle.color,
                        alpha: particle.alpha * 0.5,
                        life: 0.3 + Math.random() * 0.2,
                        decay: 0.1 + Math.random() * 0.1,
                        inkDrop: false
                    });
                }
            }
        }
        
        // Draw hexagon light particle
        function drawLightParticleHexagon(particle, size) {
            const sides = 6;
            
            // Draw shape
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * Math.PI * 2;
                const x = Math.cos(angle) * size;
                const y = Math.sin(angle) * size;
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            // Fill with light color
            const r = particle.color.r;
            const g = particle.color.g;
            const b = particle.color.b;
            
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.alpha * 0.3})`;
            ctx.fill();
            
            // Draw outline
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${particle.alpha})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw bright center
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r + 100}, ${g + 100}, ${b + 100}, ${particle.alpha})`;
            ctx.fill();
        }
        
        // Draw tetrahedron light particle
        function drawLightParticleTetrahedron(particle, size) {
            // Draw a simplified tetrahedron (triangle)
            ctx.beginPath();
            ctx.moveTo(0, -size);
            ctx.lineTo(-size * 0.866, size * 0.5);
            ctx.lineTo(size * 0.866, size * 0.5);
            ctx.closePath();
            
            // Fill with light color
            const r = particle.color.r;
            const g = particle.color.g;
            const b = particle.color.b;
            
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particle.alpha * 0.3})`;
            ctx.fill();
            
            // Draw outline
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${particle.alpha})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Draw bright center
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${r + 100}, ${g + 100}, ${b + 100}, ${particle.alpha})`;
            ctx.fill();
        }
        
        // Draw portal
        function drawPortal() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const size = portalTransition.portalSize;
            const isDramatic = portalTransition.isDramatic;
            
            ctx.save();
            
            // For dramatic portal, create camera shake effect
            if (isDramatic) {
                const shakeIntensity = 3 + Math.sin(time * 5) * 2;
                const shakeX = (Math.random() - 0.5) * shakeIntensity;
                const shakeY = (Math.random() - 0.5) * shakeIntensity;
                ctx.translate(shakeX, shakeY);
            }
            
            ctx.translate(centerX, centerY);
            ctx.rotate(portalTransition.portalRotation);
            
            // Draw outer glow
            const outerGlow = ctx.createRadialGradient(0, 0, size * 0.7, 0, 0, size * 1.3);
            outerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
            outerGlow.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.beginPath();
            ctx.arc(0, 0, size * 1.3, 0, Math.PI * 2);
            ctx.fillStyle = outerGlow;
            ctx.fill();
            
            // Draw main portal - geometric prism
            const sides = 8; // Octagon
            const sideAngle = (Math.PI * 2) / sides;
            
            // Draw inner portal body
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = i * sideAngle + Math.sin(time * 0.5) * 0.1;
                const radius = size * (0.9 + Math.sin(time * 2 + i) * 0.05);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            // Create radial gradient for portal interior
            const portalGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
            portalGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
            portalGradient.addColorStop(0.3, 'rgba(220, 240, 255, 0.8)');
            portalGradient.addColorStop(0.7, 'rgba(180, 210, 240, 0.7)');
            portalGradient.addColorStop(1, 'rgba(150, 180, 220, 0.6)');
            
            ctx.fillStyle = portalGradient;
            ctx.fill();
            
            // Draw geometric patterns inside the portal
            for (let i = 0; i < 3; i++) {
                const innerSize = size * (0.7 - i * 0.2);
                const rotation = time * (0.2 + i * 0.1) + i * Math.PI / 4;
                
                ctx.save();
                ctx.rotate(rotation);
                
                ctx.beginPath();
                for (let j = 0; j < sides; j++) {
                    const angle = j * sideAngle;
                    const x = Math.cos(angle) * innerSize;
                    const y = Math.sin(angle) * innerSize;
                    
                    if (j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.3 + i * 0.1})`;
                ctx.lineWidth = 2 - i * 0.5;
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Draw portal edge
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const angle = i * sideAngle + Math.sin(time * 0.5) * 0.1;
                const radius = size * (0.9 + Math.sin(time * 2 + i) * 0.05);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            // Add pulsing rings radiating from portal
            const ringCount = 3;
            for (let i = 0; i < ringCount; i++) {
                const ringProgress = ((time * 0.7) + (i / ringCount)) % 1.0;
                const ringRadius = size + ringProgress * size * 1.5;
                
                if (ringRadius > size && ringRadius < size * 2.5) {
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${(1 - ringProgress) * 0.5})`;
                    ctx.lineWidth = 2 * (1 - ringProgress);
                    ctx.stroke();
                }
            }
            
            ctx.restore();
            
            // Draw lens flare
            drawLensFlare(centerX, centerY, size);
            
            // Create occasional particles from the portal
            if (Math.random() > 0.8) {
                const angle = Math.random() * Math.PI * 2;
                const distance = size * (0.7 + Math.random() * 0.3);
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                
                // Small bright particles
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * (20 + Math.random() * 30),
                    vy: Math.sin(angle) * (20 + Math.random() * 30),
                    size: 2 + Math.random() * 3,
                    color: { r: 200, g: 220, b: 255 },
                    alpha: 0.7 + Math.random() * 0.3,
                    life: 0.3 + Math.random() * 0.3,
                    decay: 0.05 + Math.random() * 0.05,
                    inkDrop: false
                });
            }
        }
        
        // Draw lens flare effect
        function drawLensFlare(x, y, size) {
            const isDramatic = portalTransition.isDramatic;
            
            // Main glow
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 0.5);
            
            if (isDramatic) {
                // More intense, colorful glow for dramatic portal
                gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
                gradient.addColorStop(0.3, 'rgba(230, 240, 255, 0.7)');
                gradient.addColorStop(0.7, 'rgba(200, 220, 255, 0.4)');
                gradient.addColorStop(1, 'rgba(180, 200, 255, 0)');
            } else {
                // Standard glow
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                gradient.addColorStop(0.3, 'rgba(220, 240, 255, 0.5)');
                gradient.addColorStop(1, 'rgba(220, 240, 255, 0)');
            }
            
            ctx.beginPath();
            ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Horizontal light streak
            ctx.save();
            ctx.translate(x, y);
            
            const streakCount = isDramatic ? 6 : 4;
            for (let i = 0; i < streakCount; i++) {
                const angle = i * Math.PI / (streakCount/2) + time * 0.2;
                const streakLength = size * (isDramatic ? 1.5 : 1.0);
                
                ctx.save();
                ctx.rotate(angle);
                
                // Draw light streak
                const streakGradient = ctx.createLinearGradient(0, -streakLength, 0, streakLength);
                streakGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                streakGradient.addColorStop(0.5, `rgba(255, 255, 255, ${isDramatic ? 0.4 : 0.3})`);
                streakGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.beginPath();
                ctx.moveTo(0, -streakLength);
                ctx.lineTo(0, streakLength);
                ctx.strokeStyle = streakGradient;
                ctx.lineWidth = (isDramatic ? 15 : 10) + Math.sin(time * 2) * 5;
                ctx.stroke();
                
                ctx.restore();
            }
            
            ctx.restore();
            
            // Small lens flare circles
            const flareCount = isDramatic ? 8 : 5;
            const flarePositions = [];
            
            // Generate flare positions dynamically
            for (let i = 0; i < flareCount; i++) {
                const t = i / (flareCount - 1); // 0 to 1
                const dist = isDramatic ? 
                    (t * 2 - 1) * 1.5 : // -1.5 to 1.5 for dramatic
                    (t * 2 - 1);        // -1 to 1 for normal
                
                const sizeScale = isDramatic ?
                    0.16 - Math.abs(dist) * 0.08 :
                    0.15 - Math.abs(dist) * 0.1;
                    
                const opacity = isDramatic ?
                    0.5 - Math.abs(dist) * 0.2 :
                    0.4 - Math.abs(dist) * 0.2;
                
                flarePositions.push({
                    dist: dist,
                    size: sizeScale,
                    opacity: opacity
                });
            }
            
            // Draw all the small flares along an imaginary line through the center
            for (let flare of flarePositions) {
                // Position flares along vector from center to corner
                const flareX = x + (canvas.width / 2 - x) * flare.dist;
                const flareY = y + (canvas.height / 2 - y) * flare.dist;
                const flareSize = size * flare.size;
                
                // Add pulsing for dramatic flares
                const flareOpacity = isDramatic ? 
                    flare.opacity * (0.8 + Math.sin(time * 4 + flare.dist) * 0.2) :
                    flare.opacity;
                
                // Draw flare circle
                ctx.beginPath();
                ctx.arc(flareX, flareY, flareSize, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${flareOpacity})`;
                ctx.fill();
                
                // Draw ring around flare
                ctx.beginPath();
                ctx.arc(flareX, flareY, flareSize * 1.5, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255, 255, 255, ${flareOpacity * 0.5})`;
                ctx.lineWidth = isDramatic ? 1.5 : 1;
                ctx.stroke();
                
                // For dramatic flares, add an extra outer ring
                if (isDramatic && Math.random() > 0.5) {
                    ctx.beginPath();
                    ctx.arc(flareX, flareY, flareSize * 2.5, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${flareOpacity * 0.2})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }
        
        // Easing function for smoother animations
        function easeInOutCubic(t) {
            return t < 0.5 
                ? 4 * t * t * t 
                : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }
        
        // Draw indicator showing the alternation rate and overload progress
        function drawOverloadIndicator() {
            const width = 120;
            const height = 8;
            const x = canvas.width - width - 20;
            const y = 20;
            
            ctx.save();
            
            // Draw background bar
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(x, y, width, height);
            
            // Draw progress bar
            const fillWidth = width * overloadProgress;
            const gradient = ctx.createLinearGradient(x, y, x + fillWidth, y);
            gradient.addColorStop(0, 'rgba(255, 100, 50, 0.7)');
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0.9)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, fillWidth, height);
            
            // Draw flashing warning effect as overload approaches
            if (overloadProgress > 0.8) {
                const flash = Math.sin(time * 10) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${flash * 0.5})`;
                ctx.fillRect(x, y, width, height);
            }
            
            // Draw visualization of alternation rate
            const rateY = y + height + 15;
            const rateHeight = 30;
            
            // Draw small dots for recent gesture changes
            const maxAge = 8000; // 8 seconds
            const now = performance.now();
            
            for (let i = 0; i < gestureHistory.length; i++) {
                const entry = gestureHistory[i];
                const age = now - entry.time;
                if (age < maxAge) {
                    const relativeX = x + width * (1 - age / maxAge);
                    const dotY = rateY + (entry.to === 'Click' ? rateHeight * 0.25 : rateHeight * 0.75);
                    const opacity = 1 - (age / maxAge);
                    
                    ctx.beginPath();
                    ctx.arc(relativeX, dotY, 3, 0, Math.PI * 2);
                    
                    // Different colors for different gestures
                    if (entry.to === 'Click') {
                        ctx.fillStyle = `rgba(100, 150, 255, ${opacity})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 100, 100, ${opacity})`;
                    }
                    ctx.fill();
                    
                    // Draw connector lines between alternations
                    if (i > 0 && gestureHistory[i-1].time > now - maxAge) {
                        const prevEntry = gestureHistory[i-1];
                        const prevX = x + width * (1 - (now - prevEntry.time) / maxAge);
                        const prevY = rateY + (prevEntry.to === 'Click' ? rateHeight * 0.25 : rateHeight * 0.75);
                        
                        ctx.beginPath();
                        ctx.moveTo(prevX, prevY);
                        ctx.lineTo(relativeX, dotY);
                        ctx.strokeStyle = `rgba(200, 200, 200, ${opacity * 0.5})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }
            }
            
            // Draw current alternation rate text
            ctx.font = '14px Arial';
            ctx.textAlign = 'right';
            ctx.fillStyle = overloadProgress > 0.7 ? 'rgba(255, 50, 50, 0.9)' : 'rgba(0, 0, 0, 0.7)';
            ctx.fillText(`${alternationRate.toFixed(1)} Hz`, x + width, y + height + 5);
            
            // Show instruction if not close to overloaded
            if (overloadProgress < 0.3) {
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillText('Alternate Click/Hold (0.5 Hz)', x - 140, y + 8);
            }
            
            // Draw countdown number
            if (countdownLevel > 0) {
                const countX = x - 50;
                const countY = y + 20;
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                
                // Add pulsing effect to the countdown number
                const pulseFactor = 1 + Math.sin(time * 6) * 0.2;
                ctx.save();
                ctx.translate(countX, countY);
                ctx.scale(pulseFactor, pulseFactor);
                
                // Draw countdown number
                const countText = countdownLevel.toString();
                ctx.fillText(countText, 0, 0);
                ctx.strokeText(countText, 0, 0);
                
                ctx.restore();
                
                // Draw "alternations to overload" text
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText('to overload', countX, countY + 20);
            }
            
            // Draw alternation count
            if (alternationCount > 0) {
                const successX = x + width + 40;
                const successY = y + 5;
                
                // Draw successful alternation count
                ctx.font = '12px Arial';
                ctx.textAlign = 'left';
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText(`${alternationCount} alternations`, successX, successY);
            }
            
            ctx.restore();
        }
        
        // Trigger network overload - the beginning of the collapse sequence
        function triggerNetworkOverload() {
            if (window.redirectInProgress) return; // Don't trigger if redirect in progress
            
            isNetworkOverloaded = true;
            collapsePhase = 1;
            collapseStartTime = time;
            
            // Hide portal button
            document.getElementById('portalButton').classList.remove('visible');
        }
        
        // Update the collapse sequence
        function updateCollapseSequence() {
            if (window.redirectInProgress) return; // Don't update if redirect in progress
            
            try {
            const elapsedTime = time - collapseStartTime;
            
                // Phase transitions based on extended timing for longer animation (10+ seconds)
            if (collapsePhase === 1 && elapsedTime > 3) {
                // After overload phase, move to face flashes
                collapsePhase = 2;
                // Generate face flashes
                generateFaceFlashes();
            } else if (collapsePhase === 2 && elapsedTime > 6) {
                // After face flashes, move to shattering
                collapsePhase = 3;
                generateShards();
            } else if (collapsePhase === 3 && elapsedTime > 10) {
                // After shattering, move to fluid phase
                collapsePhase = 4;
                collapseProgress = 0;  // Reset progress for fluid animation
                } else if (collapsePhase === 4 && elapsedTime > 22 && !window.redirectInProgress) {
                    // Extended fluid phase from 15 to 22 seconds for a longer, more artistic transition
                console.log("Fluid phase complete - initiating redirect");
                
                // Set all flags to prevent any other redirects
                window.redirectInProgress = true;
                nextSceneRedirect = true;
                redirectInitiated = true;
                
                    // Use safe redirect function instead of direct navigation
                    safeRedirect();
                    return;
            }
            
            // Update based on current phase
            switch (collapsePhase) {
                case 1: // Overload phase - update overload effects
                    updateOverloadEffects(elapsedTime);
                    break;
                case 2: // Faces phase - update face flashes
                    updateFaceFlashes(elapsedTime);
                    break;
                case 3: // Shards phase - update shards
                    updateShards(elapsedTime);
                    break;
                case 4: // Fluid phase - update mercury fluid
                    updateFluidPhase(elapsedTime);
                    break;
                }
            } catch (e) {
                console.error("Error in updateCollapseSequence:", e);
                safeRedirect();
            }
        }
        
        // Draw the collapse sequence
        function drawCollapseSequence() {
            switch (collapsePhase) {
                case 1: // Overload phase
                    drawOverloadPhase();
                    break;
                case 2: // Faces phase
                    drawFacesPhase();
                    break;
                case 3: // Shards phase
                    drawShardsPhase();
                    break;
                case 4: // Fluid phase
                    drawFluidPhase();
                    break;
            }
        }
        
        // Update overload effects
        function updateOverloadEffects(elapsedTime) {
            // Increase network instability
            const progress = Math.min(1, elapsedTime / 3);
            
            // Generate glitch particles
            if (Math.random() > 0.8) {
                const glitchCount = 5 + Math.floor(Math.random() * 10);
                
                for (let i = 0; i < glitchCount; i++) {
                    const x = Math.random() * canvas.width;
                    const y = Math.random() * canvas.height;
                    const size = 3 + Math.random() * 10;
                    
                    // Random direction and speed
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 200;
                    
                    particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: size,
                        color: { 
                            r: Math.random() > 0.5 ? 255 : 0, 
                            g: Math.random() > 0.7 ? 255 : 0, 
                            b: Math.random() > 0.6 ? 255 : 0 
                        },
                        alpha: 0.7 + Math.random() * 0.3,
                        life: 0.3 + Math.random() * 0.5,
                        decay: 0.05 + Math.random() * 0.1,
                        inkDrop: false,
                        isGlitch: true,
                        glitchType: Math.floor(Math.random() * 3) // 0: rectangle, 1: line, 2: circle
                    });
                }
            }
            
            // Apply random "jitters" to connections
            if (Math.random() > 0.95) {
                for (let conn of connections) {
                    // Regenerate path points with more distortion
                    conn.pathPoints = [];
                    conn.pathAmplitude *= (1 + Math.random() * 0.5);
                    conn.startTime = time; // Force paths to update next frame
                }
            }
        }
        
        // Draw overload phase
        function drawOverloadPhase() {
            // Draw network with overload effects
            updateAndDrawLightBeams();
            updateAndDrawConnections();
            updateAndDrawIchorDrops();
            
            // Sort and draw prisms
            prisms.sort((a, b) => (a.y + a.zOffset * 100) - (b.y + b.zOffset * 100));
            for (let prism of prisms) {
                drawPrism(prism);
            }
            
            // Draw prism clones
            updateAndDrawPrismClones();
            
            // Draw cracks
            drawCracks();
            
            // Draw glitch overlay
            drawGlitchOverlay();
        }
        
        // Draw glitch overlay effects
        function drawGlitchOverlay() {
            // Draw semi-transparent overlay
            const elapsedTime = time - collapseStartTime;
            const intensity = Math.min(0.3, elapsedTime * 0.1);
            
            // Random screen tearing effect
            if (Math.random() > 0.9) {
                const tearCount = 1 + Math.floor(Math.random() * 3);
                
                for (let i = 0; i < tearCount; i++) {
                    const x1 = 0;
                    const x2 = canvas.width;
                    const y = Math.random() * canvas.height;
                    const height = 2 + Math.floor(Math.random() * 20);
                    const shift = Math.random() * 50 * (Math.random() > 0.5 ? 1 : -1);
                    
                    // Draw shifted slice
                    ctx.save();
                    ctx.globalAlpha = 0.8;
                    ctx.globalCompositeOperation = 'lighten';
                    
                    // Get image data and draw it shifted
                    try {
                        const imageData = ctx.getImageData(x1, y, x2 - x1, height);
                        ctx.putImageData(imageData, x1 + shift, y);
                    } catch (e) {
                        // Handle security errors from cross-origin data
                        console.log("Screen tear effect error:", e);
                    }
                    
                    ctx.restore();
                }
            }
            
            // Color channel splitting
            if (Math.random() > 0.8) {
                ctx.save();
                try {
                    const shiftX = Math.floor((Math.random() - 0.5) * 15);
                    const shiftY = Math.floor((Math.random() - 0.5) * 15);
                    const region = {
                        x: canvas.width * 0.3,
                        y: canvas.height * 0.3,
                        width: canvas.width * 0.4,
                        height: canvas.height * 0.4
                    };
                    
                    // Get image data for the region
                    const data = ctx.getImageData(region.x, region.y, region.width, region.height);
                    
                    // Red channel shift
                    ctx.globalCompositeOperation = 'screen';
                    ctx.globalAlpha = 0.5;
                    ctx.drawImage(canvas, region.x, region.y, region.width, region.height, 
                                         region.x + shiftX, region.y + shiftY, region.width, region.height);
                    
                } catch (e) {
                    console.log("Color channel effect error:", e);
                }
                ctx.restore();
            }
            
            // Static noise effect
            ctx.save();
            ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.1})`;
            
            const noiseCount = 500;
            for (let i = 0; i < noiseCount; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = 1 + Math.random() * 2;
                ctx.fillRect(x, y, size, size);
            }
            
            ctx.restore();
        }
        
        // Generate face data for reflection flashes
        function generateFaceFlashes() {
            facesData.length = 0;
            
            // Create several randomized face flash events
            const flashCount = 12 + Math.floor(Math.random() * 8);
            
            for (let i = 0; i < flashCount; i++) {
                // Each face has random timing, position, etc.
                facesData.push({
                    // Random time offset when this face appears
                    startTime: time + Math.random() * 3, 
                    // Duration the face is visible
                    duration: 0.1 + Math.random() * 0.2, 
                    // Position - prioritize prism locations
                    x: (i < prisms.length) ? 
                        prisms[Math.floor(Math.random() * prisms.length)].x : 
                        canvas.width * Math.random(),
                    y: (i < prisms.length) ? 
                        prisms[Math.floor(Math.random() * prisms.length)].y : 
                        canvas.height * Math.random(),
                    // Size of the face
                    size: 50 + Math.random() * 150,
                    // Rotation
                    rotation: Math.random() * Math.PI * 2,
                    // Distortion level
                    distortion: 0.1 + Math.random() * 0.5,
                    // Face index (would reference real image if available)
                    faceIndex: Math.floor(Math.random() * 5),
                    // Alpha transparency
                    alpha: 0.1 + Math.random() * 0.4,
                    // Whether the face has flashed
                    hasFlashed: false
                });
            }
        }
        
        // Update face flashes
        function updateFaceFlashes(elapsedTime) {
            // Generate more glitch particles as in overload phase
            updateOverloadEffects(elapsedTime);
            
            // Check if faces should be visible
            for (let face of facesData) {
                if (!face.hasFlashed && time >= face.startTime) {
                    face.hasFlashed = true;
                    
                    // Generate some particles around the face for effect
                    const particleCount = 10 + Math.floor(Math.random() * 10);
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = face.size * 0.5 * Math.random();
                        const x = face.x + Math.cos(angle) * distance;
                        const y = face.y + Math.sin(angle) * distance;
                        
                        particles.push({
                            x, y,
                            vx: Math.cos(angle) * 50,
                            vy: Math.sin(angle) * 50,
                            size: 2 + Math.random() * 3,
                            color: { r: 255, g: 255, b: 255 },
                            alpha: 0.7,
                            life: 0.3 + Math.random() * 0.2,
                            decay: 0.1 + Math.random() * 0.1,
                            inkDrop: false
                        });
                    }
                }
            }
        }
        
        // Draw faces phase
        function drawFacesPhase() {
            // Draw network with overload effects first
            drawOverloadPhase();
            
            // Draw face flashes
            for (let face of facesData) {
                // Only draw faces during their visibility window
                if (face.hasFlashed && time < face.startTime + face.duration) {
                    drawDistortedFace(face);
                }
            }
        }
        
        // Draw a distorted face
        function drawDistortedFace(face) {
            ctx.save();
            
            // Apply camera offset
            const drawX = face.x - cameraX;
            const drawY = face.y - cameraY;
            
            ctx.translate(drawX, drawY);
            ctx.rotate(face.rotation);
            
            // Create a circular mask
            ctx.beginPath();
            ctx.arc(0, 0, face.size / 2, 0, Math.PI * 2);
            ctx.clip();
            
            // Draw the face
            // Since we don't have actual face images, we'll create an abstract representation
            // of a face using simple shapes with distortion
            
            const faceColor = `rgba(240, 230, 210, ${face.alpha})`; // Skin tone with given alpha
            const time = performance.now() / 1000;
            
            // Draw base face shape
            ctx.fillStyle = faceColor;
            ctx.beginPath();
            ctx.arc(0, 0, face.size * 0.4, 0, Math.PI * 2);
            ctx.fill();
            
            // Apply distortions using sine waves
            const distortionAmount = face.distortion * 20;
            
            // Draw abstract eyes
            for (let i = -1; i <= 1; i += 2) {
                if (i === 0) continue;
                
                const eyeX = i * face.size * 0.15;
                const eyeY = -face.size * 0.07;
                
                // Add distortion
                const eyeDistX = eyeX + Math.sin(time * 10) * distortionAmount;
                const eyeDistY = eyeY + Math.cos(time * 8) * distortionAmount;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.beginPath();
                ctx.ellipse(
                    eyeDistX, 
                    eyeDistY, 
                    face.size * 0.07, 
                    face.size * 0.05 * (1 + Math.sin(time * 5) * 0.2), 
                    0, 0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Draw abstract mouth
            const mouthY = face.size * 0.15;
            const mouthDistY = mouthY + Math.sin(time * 12) * distortionAmount;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.beginPath();
            ctx.ellipse(0, mouthDistY, face.size * 0.15, face.size * 0.05, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Add glitch elements
            const glitchCount = Math.floor(3 + face.distortion * 10);
            for (let i = 0; i < glitchCount; i++) {
                const glitchX = (Math.random() - 0.5) * face.size;
                const glitchY = (Math.random() - 0.5) * face.size;
                const glitchW = 5 + Math.random() * 30;
                const glitchH = 3 + Math.random() * 10;
                
                // Random color - sometimes skin tone, sometimes distorted
                ctx.fillStyle = Math.random() > 0.5 ? 
                    faceColor : 
                    `rgba(${Math.random()*255}, ${Math.random()*255}, ${Math.random()*255}, ${face.alpha})`;
                
                ctx.fillRect(glitchX, glitchY, glitchW, glitchH);
            }
            
            // Add some static noise
            ctx.fillStyle = `rgba(0, 0, 0, ${face.alpha * 0.3})`;
            for (let i = 0; i < 100; i++) {
                const noiseX = (Math.random() - 0.5) * face.size;
                const noiseY = (Math.random() - 0.5) * face.size;
                const noiseSize = 1 + Math.random() * 2;
                ctx.fillRect(noiseX, noiseY, noiseSize, noiseSize);
            }
            
            ctx.restore();
        }
        
        // Generate glass-like shards from prisms
        function generateShards() {
            shards.length = 0;
            
            // Create shards from each prism
            for (let prism of prisms) {
                const shardCount = 6 + Math.floor(Math.random() * 6);
                
                for (let i = 0; i < shardCount; i++) {
                    // Create shard shapes based on prism type
                    let vertices = [];
                    
                    if (prism.type === 'hexagon') {
                        // Create triangular fragment from hexagon
                        const centerAngle = (i / shardCount) * Math.PI * 2;
                        const angleSpread = Math.PI / (3 + Math.random() * 3);
                        
                        // First vertex at center
                        vertices.push({x: 0, y: 0});
                        
                        // Two vertices at the edges
                        vertices.push({
                            x: Math.cos(centerAngle - angleSpread) * prism.size,
                            y: Math.sin(centerAngle - angleSpread) * prism.size
                        });
                        
                        vertices.push({
                            x: Math.cos(centerAngle + angleSpread) * prism.size,
                            y: Math.sin(centerAngle + angleSpread) * prism.size
                        });
                    } else {
                        // For tetrahedron, just split into smaller triangles
                        // Choose a portion of the triangle to break off
                        const pointA = {x: 0, y: -prism.size};
                        const pointB = {x: -prism.size * 0.866, y: prism.size * 0.5};
                        const pointC = {x: prism.size * 0.866, y: prism.size * 0.5};
                        
                        let segPoints;
                        switch (i % 3) {
                            case 0:
                                segPoints = [pointA, pointB, pointC];
                                break;
                            case 1:
                                segPoints = [
                                    pointA,
                                    {x: (pointA.x + pointB.x) / 2, y: (pointA.y + pointB.y) / 2},
                                    {x: (pointA.x + pointC.x) / 2, y: (pointA.y + pointC.y) / 2}
                                ];
                                break;
                            case 2:
                                segPoints = [
                                    pointB,
                                    {x: (pointB.x + pointA.x) / 2, y: (pointB.y + pointA.y) / 2},
                                    {x: (pointB.x + pointC.x) / 2, y: (pointB.y + pointC.y) / 2}
                                ];
                                break;
                            default:
                                segPoints = [
                                    pointC,
                                    {x: (pointC.x + pointA.x) / 2, y: (pointC.y + pointA.y) / 2},
                                    {x: (pointC.x + pointB.x) / 2, y: (pointC.y + pointB.y) / 2}
                                ];
                        }
                        
                        // Add some randomness to the points
                        vertices = segPoints.map(p => ({
                            x: p.x + (Math.random() - 0.5) * prism.size * 0.2,
                            y: p.y + (Math.random() - 0.5) * prism.size * 0.2
                        }));
                    }
                    
                    // Calculate a random velocity for this shard
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 20 + Math.random() * 80;
                    
                    // Create the shard
                    shards.push({
                        x: prism.x,
                        y: prism.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed + 50, // Add downward component
                        vertices: vertices,
                        rotation: prism.rotation,
                        rotationSpeed: (Math.random() - 0.5) * 0.2,
                        color: {...prism.color},
                        alpha: 0.6 + Math.random() * 0.4,
                        reflectivity: 0.5 + Math.random() * 0.5,
                        zOffset: prism.zOffset,
                        creationTime: time,
                        hasBecomeLiquid: false
                    });
                }
                
                // Also create some smaller particles
                const particleCount = 10 + Math.floor(Math.random() * 10);
                for (let i = 0; i < particleCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 50 + Math.random() * 150;
                    
                    particles.push({
                        x: prism.x,
                        y: prism.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: 1 + Math.random() * 3,
                        color: { r: 0, g: 0, b: 0 },
                        alpha: 0.8,
                        life: 0.5 + Math.random() * 0.5,
                        decay: 0.05 + Math.random() * 0.1,
                        inkDrop: true,
                        isShard: true
                    });
                }
            }
            
            // Clear all the prisms, clones, etc.
            prisms.length = 0;
            prismClones.length = 0;
            connections.length = 0;
            lightBeams.length = 0;
            damagedAreas.length = 0;
        }
        
        // Update shards
        function updateShards(elapsedTime) {
            const progress = (elapsedTime - 6) / 4; // 6-10 second timeframe
            
            for (let i = shards.length - 1; i >= 0; i--) {
                const shard = shards[i];
                
                // Apply gravity
                shard.vy += 120 * deltaTime;
                
                // Update position
                shard.x += shard.vx * deltaTime;
                shard.y += shard.vy * deltaTime;
                
                // Update rotation
                shard.rotation += shard.rotationSpeed * deltaTime;
                
                // Check if out of bounds or should become liquid
                if (progress > 0.7 && !shard.hasBecomeLiquid) {
                    // Convert to mercury droplet
                    shard.hasBecomeLiquid = true;
                    
                    // Create fluid droplet
                    fluidDroplets.push({
                        x: shard.x,
                        y: shard.y,
                        vx: shard.vx * 0.2,
                        vy: shard.vy * 0.5,
                        size: 10 + Math.random() * 15,
                        alpha: 0.8 + Math.random() * 0.2,
                        reflectivity: 0.8 + Math.random() * 0.2,
                        creationTime: time
                    });
                    
                    // Mark for removal
                    shards.splice(i, 1);
                } else if (shard.y > canvas.height + 100) {
                    // Remove if off screen
                    shards.splice(i, 1);
                }
            }
            
            // Create occasional new shards near the top to maintain some density
            if (shards.length < 100 && progress < 0.7 && Math.random() > 0.9) {
                const newShardCount = 5 + Math.floor(Math.random() * 5);
                
                for (let i = 0; i < newShardCount; i++) {
                    // Create a triangular shard
                    const vertices = [];
                    const size = 20 + Math.random() * 40;
                    
                    // Create a triangular shape
                    for (let j = 0; j < 3; j++) {
                        const angle = (j / 3) * Math.PI * 2;
                        vertices.push({
                            x: Math.cos(angle) * size * (0.8 + Math.random() * 0.4),
                            y: Math.sin(angle) * size * (0.8 + Math.random() * 0.4)
                        });
                    }
                    
                    // Create a shard near the top of the screen
                    shards.push({
                        x: Math.random() * canvas.width,
                        y: -50 - Math.random() * 100,
                        vx: (Math.random() - 0.5) * 100,
                        vy: 100 + Math.random() * 150,
                        vertices: vertices,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.5,
                        color: {
                            r: 0 + Math.floor(Math.random() * 30),
                            g: 0 + Math.floor(Math.random() * 30),
                            b: 0 + Math.floor(Math.random() * 30)
                        },
                        alpha: 0.6 + Math.random() * 0.4,
                        reflectivity: 0.5 + Math.random() * 0.5,
                        zOffset: Math.random(),
                        creationTime: time,
                        hasBecomeLiquid: false
                    });
                }
            }
        }
        
        // Draw shards phase
        function drawShardsPhase() {
            // Clear with a dark background
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Sort shards by y-position for pseudo-3D effect
            shards.sort((a, b) => (a.y + a.zOffset * 100) - (b.y + b.zOffset * 100));
            
            // Draw each shard
            for (let shard of shards) {
                drawShard(shard);
            }
            
            // Draw existing fluid droplets
            for (let droplet of fluidDroplets) {
                drawFluidDroplet(droplet);
            }
        }
        
        // Draw a glass shard
        function drawShard(shard) {
            // Apply camera offset for consistency
            const drawX = shard.x - cameraX;
            const drawY = shard.y - cameraY;
            
            ctx.save();
            ctx.translate(drawX, drawY);
            ctx.rotate(shard.rotation);
            
            // Draw shard
            ctx.beginPath();
            for (let i = 0; i < shard.vertices.length; i++) {
                const vertex = shard.vertices[i];
                if (i === 0) {
                    ctx.moveTo(vertex.x, vertex.y);
                } else {
                    ctx.lineTo(vertex.x, vertex.y);
                }
            }
            ctx.closePath();
            
            // Fill with a gradient that simulates glass/mirror reflection
            const gradientCenterX = Math.cos(time * 0.5) * 20;
            const gradientCenterY = Math.sin(time * 0.5) * 20;
            const maxDist = 40;
            
            const gradient = ctx.createRadialGradient(
                gradientCenterX, gradientCenterY, 0,
                gradientCenterX, gradientCenterY, maxDist
            );
            
            // Base color from the original prism
            const r = shard.color.r;
            const g = shard.color.g;
            const b = shard.color.b;
            
            // A more reflective/metallic look
            gradient.addColorStop(0, `rgba(220, 220, 220, ${shard.alpha * shard.reflectivity})`);
            gradient.addColorStop(0.5, `rgba(${r+50}, ${g+50}, ${b+50}, ${shard.alpha * 0.9})`);
            gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${shard.alpha * 0.7})`);
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add glass-like edge
            ctx.lineWidth = 1;
            ctx.strokeStyle = `rgba(255, 255, 255, ${shard.alpha * 0.5})`;
            ctx.stroke();
            
            ctx.restore();
        }
        
        // Draw a fluid droplet (mercury-like)
        function drawFluidDroplet(droplet) {
            const drawX = droplet.x - cameraX;
            const drawY = droplet.y - cameraY;
            
            ctx.save();
            
            // Draw the metallic droplet
            ctx.beginPath();
            ctx.arc(drawX, drawY, droplet.size, 0, Math.PI * 2);
            
            // Create mirror-like gradient
            const angle = time * 0.5;
            const highlightX = Math.cos(angle) * droplet.size * 0.5;
            const highlightY = Math.sin(angle) * droplet.size * 0.5;
            
            const gradient = ctx.createRadialGradient(
                drawX + highlightX, drawY + highlightY, 0,
                drawX + highlightX, drawY + highlightY, droplet.size * 1.5
            );
            
            gradient.addColorStop(0, `rgba(240, 240, 250, ${droplet.alpha})`);
            gradient.addColorStop(0.2, `rgba(200, 200, 210, ${droplet.alpha})`);
            gradient.addColorStop(0.5, `rgba(150, 150, 160, ${droplet.alpha})`);
            gradient.addColorStop(1, `rgba(80, 80, 90, ${droplet.alpha})`);
            
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Add metallic highlight
            ctx.beginPath();
            ctx.arc(
                drawX + highlightX * 0.8, 
                drawY + highlightY * 0.8, 
                droplet.size * 0.3, 
                0, Math.PI * 2
            );
            ctx.fillStyle = `rgba(255, 255, 255, ${droplet.alpha * 0.7})`;
            ctx.fill();
            
            ctx.restore();
        }
        
        // Update fluid phase
        function updateFluidPhase(elapsedTime) {
            try {
                // Get chaos level based on progress
                const elapsedTime = time - collapseStartTime;
                const progress = (elapsedTime - 10) / 10; // Extended from 5 to 10 seconds
                const chaosLevel = Math.min(1, progress * 2); // Intensifies faster than visible mercury
                
                // Apply visual glitches as chaos increases
                if (chaosLevel > 0.4 && Math.random() > 0.85) {
                    applyGlitchEffect(chaosLevel);
                }
                
                // Clear with a dark background that shifts color as chaos increases
                let bgH = 240; // Start with deep blue
                let bgS = 30 + chaosLevel * 30;
                let bgL = Math.max(5, 20 - chaosLevel * 20); // Gets darker
                
                if (chaosLevel > 0.7) {
                    bgH = 260 + Math.sin(time * 3) * 40; // Shift toward purple with oscillation
                    bgS = 50 + Math.sin(time * 2) * 20;
                    bgL = 5 + Math.sin(time * 5) * 10;
                }
                
                // Convert HSL to RGB
                const bgColor = hslToRgbString(bgH, bgS, bgL);
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Apply chromatic aberration as chaos increases
                if (chaosLevel > 0.5) {
                    applyChromaticAberration(chaosLevel);
                }
                
                // Draw remaining shards with chaotic distortion
                for (let shard of shards) {
                    drawShard(shard, chaosLevel);
                }
                
                // Draw the mercury pool with enhanced effects
                drawMercuryPool(chaosLevel);
                
                // Draw fluid droplets with chaotic variations
                for (let droplet of fluidDroplets) {
                    drawFluidDroplet(droplet, chaosLevel);
                }
                
                // Draw wave particles and special effects
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    
                    if (particle.type === 'wave') {
                        // Draw only if it's time for this wave
                        if (time >= particle.startTime) {
                            const age = time - particle.startTime;
                            const progress = Math.min(1, age / (particle.life / particle.decay));
                            
                            // Radius expands over time
                            const radius = particle.radius + progress * (particle.maxRadius - particle.radius);
                            
                            ctx.save();
                            ctx.beginPath();
                            
                            // Add distortion to waves as chaos increases
                            if (chaosLevel > 0.6) {
                                drawDistortedCircle(
                                    particle.x, 
                                    particle.y, 
                                    radius, 
                                    chaosLevel * 0.4
                                );
                            } else {
                                ctx.arc(particle.x, particle.y, radius, 0, Math.PI * 2);
                            }
                            
                            // Color shifts with chaos
                            let waveColor;
                            if (particle.color) {
                                waveColor = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha * (1 - progress)})`;
                            } else if (chaosLevel > 0.7) {
                                // More vibrant colors as chaos increases
                                const hue = (time * 30 + radius) % 360;
                                waveColor = `hsla(${hue}, 70%, 60%, ${particle.alpha * (1 - progress)})`;
                            } else {
                                waveColor = `rgba(200, 200, 210, ${particle.alpha * (1 - progress)})`;
                            }
                            
                            ctx.strokeStyle = waveColor;
                            ctx.lineWidth = particle.thickness * (1 - progress) * (1 + chaosLevel * 0.5);
                            ctx.stroke();
                            ctx.restore();
                            
                            // Remove if completed
                            if (progress >= 1) {
                                particles.splice(i, 1);
                            }
                        }
                    } else if (particle.type === 'shockwave') {
                        // Draw shockwave effect
                    if (time >= particle.startTime) {
                        const age = time - particle.startTime;
                        const progress = Math.min(1, age / (particle.life / particle.decay));
                        
                        // Radius expands over time
                        const radius = particle.radius + progress * (particle.maxRadius - particle.radius);
                        
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, radius, 0, Math.PI * 2);
                            
                            // Create gradient for more dramatic effect
                            const gradient = ctx.createRadialGradient(
                                particle.x, particle.y, radius * 0.8,
                                particle.x, particle.y, radius
                            );
                            
                            const alpha = particle.alpha * (1 - progress);
                            gradient.addColorStop(0, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, 0)`);
                            gradient.addColorStop(0.5, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha * 0.5})`);
                            gradient.addColorStop(1, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`);
                            
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = particle.thickness * (1 - progress * 0.5);
                        ctx.stroke();
                        ctx.restore();
                        
                        // Remove if completed
                        if (progress >= 1) {
                            particles.splice(i, 1);
                        }
                    }
                    } else if (particle.isExplosion) {
                        // Draw explosion particles
                        const x = particle.x - cameraX;
                        const y = particle.y - cameraY;
                        
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(particle.rotation);
                        particle.rotation += particle.rotationSpeed * deltaTime;
                        
                        // Draw with glow effect
                        ctx.beginPath();
                        
                        // Random shapes for explosions
                        const shapeType = particle.shapeType || Math.floor(Math.random() * 3);
                        
                        if (shapeType === 0) {
                            // Circle
                            ctx.arc(0, 0, particle.size * particle.life, 0, Math.PI * 2);
                        } else if (shapeType === 1) {
                            // Square or diamond
                            const size = particle.size * particle.life;
                            ctx.rotate(Math.PI / 4); // Diamond orientation
                            ctx.rect(-size, -size, size * 2, size * 2);
                        } else {
                            // Star or cross
                            const size = particle.size * particle.life;
                            const innerSize = size * 0.4;
                            for (let i = 0; i < 4; i++) {
                                ctx.rotate(Math.PI / 2);
                                ctx.moveTo(0, 0);
                                ctx.lineTo(0, size);
                            }
                        }
                        
                        const r = particle.color.r;
                        const g = particle.color.g;
                        const b = particle.color.b;
                        const alpha = particle.alpha * particle.life;
                        
                        // Gradient fill for more dramatic effect
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, particle.size * particle.life);
                        gradient.addColorStop(0, `rgba(${r + 50}, ${g + 50}, ${b + 50}, ${alpha})`);
                        gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${alpha * 0.5})`);
                        
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // Add glow
                        ctx.globalCompositeOperation = 'screen';
                        ctx.beginPath();
                        ctx.arc(0, 0, particle.size * particle.life * 1.5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`;
                        ctx.fill();
                        
                        ctx.restore();
                } else if (particle.isBubble) {
                        // Draw mercury bubbles with enhanced effects
                        const drawX = particle.x - cameraX;
                        const drawY = particle.y - cameraY;
                    
                    ctx.save();
                    ctx.beginPath();
                        
                        // Distort bubbles with chaos
                        if (chaosLevel > 0.7 && Math.random() > 0.7) {
                            // Wobbling bubbles
                            drawDistortedCircle(
                                drawX, 
                                drawY, 
                                particle.size, 
                                chaosLevel * 0.3
                            );
                        } else {
                    ctx.arc(drawX, drawY, particle.size, 0, Math.PI * 2);
                        }
                        
                        // Color shifts with chaos
                        let bubbleColor;
                        if (chaosLevel > 0.8) {
                            const hue = (particle.x + time * 50) % 360;
                            bubbleColor = `hsla(${hue}, 70%, 70%, ${particle.alpha * particle.life})`;
                        } else if (particle.color) {
                            bubbleColor = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha * particle.life})`;
                        } else {
                            bubbleColor = `rgba(220, 220, 230, ${particle.alpha * particle.life})`;
                        }
                        
                        ctx.fillStyle = bubbleColor;
                    ctx.fill();
                    
                    // Add highlight
                    ctx.beginPath();
                    ctx.arc(
                        drawX - particle.size * 0.3, 
                        drawY - particle.size * 0.3, 
                        particle.size * 0.4, 
                        0, Math.PI * 2
                    );
                    ctx.fillStyle = `rgba(255, 255, 255, ${particle.alpha * particle.life * 0.7})`;
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Fade in/out for transitions
                const elapsedTransitionTime = time - collapseStartTime;
                if (elapsedTransitionTime > 18) { // Extended from 14 seconds
                // Fade out to transition to next scene
                    const fadeProgress = Math.min(1, (elapsedTransitionTime - 18) * 0.5);
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeProgress})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
                
                // Draw zoom transition if active
                if (window.zoomTransition && window.zoomTransition.active) {
                    drawZoomTransition();
                }
                
            } catch (e) {
                console.error("Error in drawFluidPhase:", e);
            }
        }
        
        // Draw distorted circle for chaotic effects
        function drawDistortedCircle(x, y, radius, distortionLevel) {
            const segments = 36;
            const angleStep = (Math.PI * 2) / segments;
            
            ctx.beginPath();
            
            for (let i = 0; i <= segments; i++) {
                const angle = i * angleStep;
                // Add noise to radius based on time and angle
                const noiseRadius = radius * (1 + distortionLevel * Math.sin(angle * 5 + time * 5) * 0.2);
                const pointX = x + Math.cos(angle) * noiseRadius;
                const pointY = y + Math.sin(angle) * noiseRadius;
                
                if (i === 0) {
                    ctx.moveTo(pointX, pointY);
                } else {
                    ctx.lineTo(pointX, pointY);
                }
            }
            
            ctx.closePath();
        }
        
        // Apply glitch effect to canvas
        function applyGlitchEffect(intensity) {
            try {
                // Horizontal glitch slices
                const sliceCount = Math.floor(3 + intensity * 7);
                
                for (let i = 0; i < sliceCount; i++) {
                    const y = Math.random() * canvas.height;
                    const height = 5 + Math.random() * 20 * intensity;
                    const offset = (Math.random() - 0.5) * 50 * intensity;
                    
                    // Get slice of canvas
                    try {
                        const imageData = ctx.getImageData(0, y, canvas.width, height);
                        // Draw it with offset
                        ctx.putImageData(imageData, offset, y);
                    } catch (e) {
                        // Ignore security errors for cross-origin data
                    }
                }
                
                // Color channel shifting
                if (intensity > 0.6 && Math.random() > 0.5) {
                    try {
                        // Extract a portion of the canvas
                        const w = canvas.width;
                        const h = canvas.height;
                        const centerX = w / 2;
                        const centerY = h / 2;
                        const portion = Math.min(w, h) * 0.8;
                        
                        const imageData = ctx.getImageData(centerX - portion/2, centerY - portion/2, portion, portion);
                        const data = imageData.data;
                        
                        // Shift red channel
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const offsetIndex = (i + Math.floor(Math.random() * 20) * 4) % data.length;
                            data[offsetIndex] = r;
                        }
                        
                        // Draw back with offset
                        ctx.putImageData(imageData, centerX - portion/2 + (Math.random() - 0.5) * 20, centerY - portion/2);
                    } catch (e) {
                        // Ignore security errors for cross-origin data
                    }
                }
            } catch (e) {
                console.error("Error in glitch effect:", e);
            }
        }
        
        // Apply chromatic aberration effect
        function applyChromaticAberration(intensity) {
            try {
                // RGB channel separation
                const shift = Math.floor(intensity * 10);
                
                // Create temporary canvas
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Copy current canvas to temp
                tempCtx.drawImage(canvas, 0, 0);
                
                // Draw red channel shifted
                ctx.globalCompositeOperation = 'screen';
                ctx.globalAlpha = 0.5;
                ctx.drawImage(tempCanvas, -shift, 0);
                
                // Draw blue channel shifted
                ctx.globalCompositeOperation = 'screen';
                ctx.drawImage(tempCanvas, shift, 0);
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0;
            } catch (e) {
                console.error("Error in chromatic aberration:", e);
            }
        }
        
        // Draw zoom transition effect
        function drawZoomTransition() {
            const transition = window.zoomTransition;
            const progress = Math.min(1, (time - transition.startTime) / transition.duration);
            transition.progress = progress;
            
            if (progress >= 1) {
                return; // Transition complete
            }
            
            // Apply zoom and rotation effects
            ctx.save();
            
            // Scale gradually increases
            const scale = 1 + progress * 3; // Zoom in by 3x
            
            // Center point for the zoom
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Apply transformations
            ctx.translate(centerX, centerY);
            ctx.scale(scale, scale);
            ctx.rotate(progress * Math.PI * 0.5); // Add slight rotation
            ctx.translate(-centerX, -centerY);
            
            // Draw vignette effect that gets stronger
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, canvas.width
            );
            
            gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(Math.max(0, 0.8 - progress * 0.8), 'rgba(0, 0, 0, 0)');
            gradient.addColorStop(1, `rgba(0, 0, 0, ${progress * 0.8})`);
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.restore();
            
            // Add luminance/brightness effect
            ctx.fillStyle = `rgba(255, 255, 255, ${progress * 0.15})`;
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }
        
        // Convert HSL to RGB string
        function hslToRgbString(h, s, l) {
            s /= 100;
            l /= 100;
            
            const a = s * Math.min(l, 1 - l);
            const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            
            const r = Math.round(f(0) * 255);
            const g = Math.round(f(8) * 255);
            const b = Math.round(f(4) * 255);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        // Create chaotic explosion of particles
        function createChaosExplosion(x, y, size) {
            const particleCount = 20 + Math.floor(Math.random() * 30);
            
            for (let i = 0; i < particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 50 + Math.random() * 250;
                const particleSize = 2 + Math.random() * 8;
                
                // Random vibrant colors for chaos
                const hue = Math.random() * 360;
                // Convert HSL to RGB for more vibrant colors
                const h = hue / 360;
                const s = 0.7 + Math.random() * 0.3;
                const l = 0.5 + Math.random() * 0.3;
                
                // Simple HSL to RGB conversion
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                
                const r = Math.round(hslToRgb(p, q, h + 1/3) * 255);
                const g = Math.round(hslToRgb(p, q, h) * 255);
                const b = Math.round(hslToRgb(p, q, h - 1/3) * 255);
                
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: particleSize,
                    color: { r, g, b },
                    alpha: 0.7 + Math.random() * 0.3,
                    life: 0.5 + Math.random() * 0.5,
                    decay: 0.01 + Math.random() * 0.03,
                    inkDrop: false,
                    isExplosion: true,
                    rotationSpeed: (Math.random() - 0.5) * 5,
                    rotation: Math.random() * Math.PI * 2
                });
            }
            
            // Add a shock wave
            particles.push({
                x, y,
                radius: 10,
                maxRadius: size * 2,
                thickness: 5 + Math.random() * 5,
                expansionSpeed: 300 + Math.random() * 200,
                color: { r: 255, g: 255, b: 255 },
                alpha: 0.7,
                life: 1.0,
                decay: 0.015,
                startTime: time,
                type: 'shockwave'
            });
        }
        
        // Create zoom transition effect
        function createZoomTransition() {
            window.zoomTransition = {
                active: true,
                startTime: time,
                duration: 2.0,
                progress: 0
            };
        }
        
        // Draw the mercury pool filling the bottom of the screen
        function drawMercuryPool(chaosLevel = 0) {
            if (mercuryLevel <= 0) return;
            
            const poolHeight = canvas.height * mercuryLevel;
            const poolTop = canvas.height - poolHeight;
            
            ctx.save();
            
            // Create gradient for mercury pool
            let gradient;
            
            if (chaosLevel > 0.7) {
                // More dramatic color shifting for the pool during high chaos
                gradient = ctx.createLinearGradient(0, poolTop, 0, canvas.height);
                
                // Calculate shifting colors based on time
                const baseHue = (time * 10) % 360;
                const secondHue = (baseHue + 60) % 360;
                const thirdHue = (baseHue + 180) % 360;
                
                gradient.addColorStop(0, `hsla(${baseHue}, 70%, 70%, 1)`);  // Light at surface
                gradient.addColorStop(0.1, `hsla(${baseHue}, 60%, 60%, 1)`);
                gradient.addColorStop(0.4, `hsla(${secondHue}, 50%, 40%, 1)`);
                gradient.addColorStop(0.7, `hsla(${thirdHue}, 60%, 30%, 1)`);
                gradient.addColorStop(1, `hsla(${thirdHue}, 70%, 15%, 1)`);    // Darker at bottom
            } else {
                // Standard mercury gradient
                gradient = ctx.createLinearGradient(0, poolTop, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(220, 220, 230, 1)');  // Light at surface
            gradient.addColorStop(0.1, 'rgba(180, 180, 190, 1)');
            gradient.addColorStop(0.5, 'rgba(120, 120, 130, 1)');
            gradient.addColorStop(1, 'rgba(80, 80, 90, 1)');    // Darker at bottom
            }
            
            // Draw main pool
            ctx.fillStyle = gradient;
            
            // For high chaos, draw more dynamic pooling
            if (chaosLevel > 0.8) {
                // Create a more dynamic, fluid-like shape
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                
                // Left edge
                ctx.lineTo(0, poolTop);
                
                // Draw chaotic surface
                const waveCount = 20;
                const waveHeight = 10 + chaosLevel * 15;
                
                for (let x = 0; x <= canvas.width; x += canvas.width / waveCount) {
                    // Multiple sine waves with different frequencies
                    const wave1 = Math.sin(x * 0.01 + time * 2) * waveHeight;
                    const wave2 = Math.sin(x * 0.05 + time * 3) * waveHeight * 0.5;
                    const wave3 = Math.sin(x * 0.02 - time * 1.5) * waveHeight * 0.7;
                    
                    const waveY = poolTop + wave1 + wave2 + wave3;
                    
                    // Add random spikes for extreme chaos
                    if (chaosLevel > 0.9 && Math.random() > 0.9) {
                        const spikeHeight = (Math.random() * 30 + 10) * -1; // Upward spike
                        ctx.lineTo(x, waveY + spikeHeight);
                        ctx.lineTo(x + 5, waveY);
                    } else {
                        ctx.lineTo(x, waveY);
                    }
                }
                
                // Right edge and bottom
                ctx.lineTo(canvas.width, poolTop);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.closePath();
                
                ctx.fill();
                
                // Add turbulent patterns in the liquid
                for (let i = 0; i < 10; i++) {
                    // Draw swirling patterns
                    const centerX = Math.random() * canvas.width;
                    const centerY = poolTop + Math.random() * poolHeight * 0.7;
                    const radius = 30 + Math.random() * 70;
                    
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    
                    const swirl = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, radius
                    );
                    
                    const hue = (time * 20 + i * 30) % 360;
                    swirl.addColorStop(0, `hsla(${hue}, 60%, 50%, 0.1)`);
                    swirl.addColorStop(0.7, `hsla(${hue}, 60%, 40%, 0.05)`);
                    swirl.addColorStop(1, `hsla(${hue}, 60%, 30%, 0)`);
                    
                    ctx.fillStyle = swirl;
                    ctx.fill();
                }
            } else {
                // Standard surface with waves
            ctx.fillRect(0, poolTop, canvas.width, poolHeight);
            }
            
            // Draw surface highlights to create ripple effect
            const waveHeight = 3 + chaosLevel * 5;
            const waveCount = 10 + Math.floor(chaosLevel * 10);
            
            // Draw subtle waves on the surface
            ctx.beginPath();
            ctx.moveTo(0, poolTop);
            
            for (let x = 0; x < canvas.width; x += canvas.width / waveCount) {
                // Calculate wave height using sine with time-based movement
                const waveY = poolTop + Math.sin(x * 0.05 + time * 2) * waveHeight;
                ctx.lineTo(x, waveY);
            }
            
            ctx.lineTo(canvas.width, poolTop);
            ctx.lineTo(canvas.width, poolTop + waveHeight * 2);
            ctx.lineTo(0, poolTop + waveHeight * 2);
            ctx.closePath();
            
            // Fill with slightly different gradient for effect
            let surfaceGradient;
            
            if (chaosLevel > 0.7) {
                // Colorful surface for high chaos
                const hue = (time * 20) % 360;
                surfaceGradient = ctx.createLinearGradient(0, poolTop - waveHeight, 0, poolTop + waveHeight * 2);
                surfaceGradient.addColorStop(0, `hsla(${hue}, 70%, 80%, 0.3)`);
                surfaceGradient.addColorStop(0.5, `hsla(${hue + 30}, 70%, 70%, 0.4)`);
                surfaceGradient.addColorStop(1, `hsla(${hue + 60}, 70%, 60%, 0)`);
            } else {
                // Standard surface highlight
                surfaceGradient = ctx.createLinearGradient(0, poolTop - waveHeight, 0, poolTop + waveHeight * 2);
            surfaceGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            surfaceGradient.addColorStop(0.5, 'rgba(200, 200, 210, 0.4)');
            surfaceGradient.addColorStop(1, 'rgba(120, 120, 130, 0)');
            }
            
            ctx.fillStyle = surfaceGradient;
            ctx.fill();
            
            // Add reflective highlights that move across the surface
            const highlightCount = 3 + Math.floor(chaosLevel * 5);
            for (let i = 0; i < highlightCount; i++) {
                const cycleTime = 8 - chaosLevel * 4;  // Time to cross the screen (faster in chaos)
                const position = ((time / cycleTime) + (i / highlightCount)) % 1;
                const x = canvas.width * position;
                
                const highlightGradient = ctx.createRadialGradient(
                    x, poolTop, 0,
                    x, poolTop, canvas.width * (0.2 + chaosLevel * 0.1)
                );
                
                if (chaosLevel > 0.7) {
                    // Colorful highlights for high chaos
                    const hue = (time * 30 + i * 60) % 360;
                    highlightGradient.addColorStop(0, `hsla(${hue}, 100%, 80%, 0.5)`);
                    highlightGradient.addColorStop(0.2, `hsla(${hue}, 100%, 70%, 0.3)`);
                    highlightGradient.addColorStop(1, `hsla(${hue}, 100%, 60%, 0)`);
                } else {
                    // Standard white highlights
                highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                highlightGradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.1)');
                highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                }
                
                ctx.fillStyle = highlightGradient;
                ctx.fillRect(0, poolTop, canvas.width, waveHeight * 4);
            }
            
            // For high chaos, add electrical-like arcs across the surface
            if (chaosLevel > 0.8 && Math.random() > 0.9) {
                drawElectricalArcs(poolTop, chaosLevel);
            }
            
            ctx.restore();
        }
        
        // Draw electrical arcs across the mercury surface
        function drawElectricalArcs(surfaceY, intensity) {
            const arcCount = 1 + Math.floor(Math.random() * 3);
            
            for (let a = 0; a < arcCount; a++) {
                // Start and end points for the arc
                const startX = Math.random() * canvas.width * 0.3;
                const endX = canvas.width - Math.random() * canvas.width * 0.3;
                
                // Create jagged lightning path
                const segments = 10 + Math.floor(Math.random() * 10);
                const points = [];
                
                // Start point
                points.push({x: startX, y: surfaceY});
                
                // Middle points with randomness
                for (let i = 1; i < segments; i++) {
                    const x = startX + (endX - startX) * (i / segments);
                    const yOffset = (Math.random() - 0.5) * 50 * intensity;
                    points.push({
                        x: x,
                        y: surfaceY + yOffset
                    });
                }
                
                // End point
                points.push({x: endX, y: surfaceY});
                
                // Draw the lightning
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                // Vary color
                const hue = (time * 30) % 360;
                
                // Glow effect
                ctx.lineWidth = 4;
                ctx.strokeStyle = `hsla(${hue}, 100%, 80%, 0.4)`;
                ctx.stroke();
                
                // Bright core
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                
                ctx.lineWidth = 2;
                ctx.strokeStyle = `hsla(${hue}, 100%, 90%, 0.8)`;
                ctx.stroke();
                
                // Add small electrical nodes at junction points
                for (let i = 1; i < points.length - 1; i++) {
                    if (Math.random() > 0.6) {
                        ctx.beginPath();
                        ctx.arc(points[i].x, points[i].y, 2 + Math.random() * 3, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${hue}, 100%, 90%, 0.8)`;
                        ctx.fill();
                    }
                }
            }
        }
        
        // Call init function to start the animation
        init();
    </script>
</body>
</html> 