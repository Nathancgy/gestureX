<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GestureX - Digital Forest</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
            color: #fff;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
        }
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 1;
            transition: opacity 2s ease-out;
        }
        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .loading-text {
            font-size: 2rem;
            letter-spacing: 0.5rem;
            color: rgba(120, 200, 255, 0.7);
            text-transform: uppercase;
        }
        .instructions {
            position: fixed;
            bottom: 0;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            border-top: 1px solid rgba(120, 200, 255, 0.3);
            padding: 15px 0;
            text-align: center;
            opacity: 0;
            animation: fade-in 3s ease-in forwards;
            animation-delay: 3s;
        }
        @keyframes fade-in {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        .instruction-text {
            max-width: 800px;
            margin: 0 auto;
            font-size: 1rem;
            line-height: 1.6;
            color: rgba(200, 230, 255, 0.8);
        }
        .transition-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        .gesture-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(60, 80, 120, 0.3);
            border: 1px solid rgba(120, 200, 255, 0.5);
            transition: all 0.3s ease;
        }
        .gesture-dot.active {
            background-color: rgba(120, 200, 255, 0.7);
            box-shadow: 0 0 10px rgba(120, 200, 255, 0.7);
        }
        .gesture-dot.click {
            background-color: rgba(200, 220, 255, 0.7);
        }
        .gesture-dot.hold {
            background-color: rgba(100, 150, 255, 0.7);
        }
    </style>
</head>
<body>
    <div class="loading" id="loadingScreen">
        <div class="loading-text">Entering Digital Forest</div>
    </div>
    
    <canvas id="forestCanvas"></canvas>
    
    <div class="instructions">
        <p class="instruction-text">Explore the digital forest â€“ plant new trees with a Click gesture, or disintegrate them with Hold. To continue your journey, perform the sequence: Click, Hold, Click.</p>
    </div>

    <div class="transition-indicator">
        <div class="gesture-dot" id="gesture-1"></div>
        <div class="gesture-dot" id="gesture-2"></div>
        <div class="gesture-dot" id="gesture-3"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script>
        // Hide loading screen after 3 seconds
        setTimeout(() => {
            document.getElementById('loadingScreen').classList.add('hidden');
        }, 3000);
        
        // Set up canvas
        const canvas = document.getElementById('forestCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // Recalculate positions when trees are implemented
        });
        
        // Connect to the WebSocket server
        const socket = io();
        
        // Hand landmark data and gesture state
        let handLandmarks = null;
        let currentGesture = '';
        let lastGesture = '';
        let handPosition = null;
        
        // Animation timing
        let time = 0;
        let lastFrameTime = 0;
        let deltaTime = 0;
        
        // Camera/view parameters for 3D feeling
        let cameraZ = 2000;
        let cameraOffset = { x: 0, y: 0 };
        let targetCameraOffset = { x: 0, y: 0 };
        
        // Stars for background
        const stars = [];
        const numStars = 500;
        
        // Constellation elements for visual cohesion with hand tracking
        const constellations = [];
        const NUM_CONSTELLATIONS = 4; // Number of constellation formations
        
        // Initialize stars and constellation patterns
        function initStars() {
            // Initialize stars
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: (Math.random() - 0.5) * canvas.width * 3,
                    y: (Math.random() - 0.5) * canvas.height * 3,
                    z: Math.random() * 2000 + 500,
                    radius: Math.random() * 1.5 + 0.5,
                    color: {
                        r: 180 + Math.random() * 75,
                        g: 180 + Math.random() * 75,
                        b: 220 + Math.random() * 35,
                        a: 0.5 + Math.random() * 0.5
                    }
                });
            }
            
            // Create constellation patterns
            createConstellations();
        }
        
        // Create constellation patterns similar to hand tracking visuals
        function createConstellations() {
            // Define constellation shapes
            const shapes = [
                // Simple triangle
                [
                    {x: -120, y: -100, z: 800, size: 3, isGold: true},
                    {x: 120, y: -100, z: 800, size: 2.5, isGold: false},
                    {x: 0, y: 100, z: 800, size: 3, isGold: true},
                    // Connections: 0-1, 1-2, 2-0
                    [[0, 1], [1, 2], [2, 0]]
                ],
                // Small dipper-like formation
                [
                    {x: -150, y: 0, z: 1200, size: 3, isGold: true},
                    {x: -70, y: 30, z: 1200, size: 2, isGold: false},
                    {x: 0, y: 0, z: 1200, size: 2.5, isGold: false},
                    {x: 80, y: -40, z: 1200, size: 2, isGold: false},
                    {x: 160, y: -100, z: 1200, size: 3, isGold: true},
                    // Connections: 0-1-2-3-4
                    [[0, 1], [1, 2], [2, 3], [3, 4]]
                ],
                // Square with center
                [
                    {x: -100, y: -100, z: 1500, size: 2.5, isGold: false},
                    {x: 100, y: -100, z: 1500, size: 2.5, isGold: false},
                    {x: 100, y: 100, z: 1500, size: 2.5, isGold: false},
                    {x: -100, y: 100, z: 1500, size: 2.5, isGold: false},
                    {x: 0, y: 0, z: 1500, size: 3, isGold: true},
                    // Connections: square + lines to center
                    [[0, 1], [1, 2], [2, 3], [3, 0], [0, 4], [1, 4], [2, 4], [3, 4]]
                ],
                // Pentagram-like shape
                [
                    {x: 0, y: -120, z: 900, size: 3, isGold: true},
                    {x: 114, y: -37, z: 900, size: 2.5, isGold: false},
                    {x: 70, y: 97, z: 900, size: 2.5, isGold: false},
                    {x: -70, y: 97, z: 900, size: 2.5, isGold: false},
                    {x: -114, y: -37, z: 900, size: 3, isGold: true},
                    // Connections: pentagram pattern
                    [[0, 2], [2, 4], [4, 1], [1, 3], [3, 0]]
                ]
            ];
            
            // Create constellations at different positions in the scene
            for (let i = 0; i < NUM_CONSTELLATIONS; i++) {
                // Pick a random constellation shape
                const shapeIndex = Math.floor(Math.random() * shapes.length);
                const shape = shapes[shapeIndex];
                
                // Random position and rotation offsets
                const offsetX = (Math.random() - 0.5) * 1500;
                const offsetY = (Math.random() - 0.5) * 1500;
                const offsetZ = Math.random() * 1500 + 500;
                const rotation = Math.random() * Math.PI * 2;
                
                // Create stars for this constellation
                const stars = [];
                const nodePoints = shape[0]; // Points before connections
                
                // Add stars with rotation applied
                for (let j = 0; j < nodePoints.length; j++) {
                    const point = nodePoints[j];
                    // Apply rotation
                    const rotatedX = point.x * Math.cos(rotation) - point.y * Math.sin(rotation);
                    const rotatedY = point.x * Math.sin(rotation) + point.y * Math.cos(rotation);
                    
                    stars.push({
                        x: offsetX + rotatedX,
                        y: offsetY + rotatedY,
                        z: offsetZ + point.z,
                        size: point.size,
                        isGold: point.isGold,
                        pulsePhase: Math.random() * Math.PI * 2,
                        pulseSpeed: 0.5 + Math.random() * 0.5
                    });
                }
                
                // Add connections
                const connections = shape[shape.length - 1];
                
                // Add constellation to array
                constellations.push({
                    stars,
                    connections,
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 0.2 + Math.random() * 0.3
                });
            }
        }
        
        // 3D projection functions
        function project3D(x, y, z) {
            const factor = cameraZ / (z + cameraZ);
            const projectedX = x * factor + canvas.width / 2 + cameraOffset.x;
            const projectedY = y * factor + canvas.height / 2 + cameraOffset.y;
            return { x: projectedX, y: projectedY, factor: factor };
        }
        
        // Data Trees
        const dataTrees = [];
        const connections = [];
        const leafImages = [];
        const NUM_TREES = 8; // Total number of trees to create
        
        // Load leaf images
        function preloadLeafImages() {
            // Paths to our Wikipedia page textures - expanded to 10 images
            const leafPaths = [
                '/static/images/leaf_data_1.png',
                '/static/images/leaf_data_2.png',
                '/static/images/leaf_data_3.png',
                '/static/images/leaf_data_4.png',
                '/static/images/leaf_data_5.png',
                '/static/images/leaf_data_6.png',
                '/static/images/leaf_data_7.png',
                '/static/images/leaf_data_8.png',
            ];
            
            // Create and load each image
            leafPaths.forEach(path => {
                const img = new Image();
                img.src = path;
                img.onerror = () => {
                    console.log(`Failed to load image: ${path}`);
                };
                leafImages.push(img);
            });
        }
        
        // Create data trees
        function createDataTrees() {
            // Clear any existing trees 
            dataTrees.length = 0;
            
            // Don't create initial trees - start with empty forest
            // Create connections (empty at first)
            createConnections();
        }
        
        // Generate branches for a data tree
        function generateBranches(tree) {
            // Increase number of branches to support more leaf clusters
            const numBranches = Math.floor(Math.random() * 5) + 7; // 7-11 branches
            
            for (let i = 0; i < numBranches; i++) {
                // Distribute branches more evenly around the tree
                const angleSegment = (Math.PI * 2) / numBranches;
                const baseAngle = i * angleSegment; 
                // Add some randomness to the angle within the segment
                const angle = baseAngle + (Math.random() - 0.5) * angleSegment * 0.6;
                
                // Branch start point somewhere along the tree height - more distributed
                // Favor upper two-thirds of the tree for better visibility
                const heightPercent = (i % 4 === 0) ? 
                    0.25 + Math.random() * 0.25 :     // Lower branches (25-50%)
                    0.5 + Math.random() * 0.35;     // Upper branches (50-85%)
                
                const startHeight = tree.height * heightPercent;
                
                // Make branches longer on average for more leaf space
                const length = tree.width * (0.9 + Math.random() * 0.9);
                const thickness = 3 + Math.random() * 8;
                
                tree.branches.push({
                    startHeight,
                    angle,
                    length,
                    thickness,
                    // Animation
                    swayPhase: Math.random() * Math.PI * 2,
                    swaySpeed: 0.15 + Math.random() * 0.25,
                    swayAmount: 0.9 + Math.random() * 1.8,
                    // Visual effect
                    branchSegments: Math.floor(3 + Math.random() * 3)
                });
            }
            
            // Add more smaller sub-branches to main branches for more attachment points
            const mainBranchCount = tree.branches.length;
            for (let i = 0; i < mainBranchCount; i++) {
                // Add sub-branches to most main branches
                if (tree.branches[i].length > tree.width * 0.7 && Math.random() > 0.2) {
                    const mainBranch = tree.branches[i];
                    
                    // Create 1-3 sub-branches
                    const subBranchCount = Math.floor(Math.random() * 3) + 1;
                    
                    for (let j = 0; j < subBranchCount; j++) {
                        // Create sub-branch at 40-90% along main branch
                        const distanceAlongBranch = 0.4 + Math.random() * 0.5;
                        
                        // Calculate sub-branch start position
                        const branchY = tree.y - mainBranch.startHeight;
                        const branchX = tree.x + Math.cos(mainBranch.angle) * mainBranch.length * distanceAlongBranch;
                        const branchZ = tree.z + Math.sin(mainBranch.angle) * mainBranch.length * distanceAlongBranch;
                        
                        // Calculate height in tree coordinates
                        const subBranchHeight = mainBranch.startHeight + 
                                               Math.sin(mainBranch.angle) * mainBranch.length * distanceAlongBranch * 0.3;
                        
                        // Sub-branch angle relative to main branch (30-150 degrees)
                        const angleOffset = (Math.random() * Math.PI * 0.67) + Math.PI/6; // 30-150 degrees
                        const subAngle = mainBranch.angle + (Math.random() > 0.5 ? angleOffset : -angleOffset);
                        
                        // Sub-branches are smaller
                        const subLength = mainBranch.length * (0.4 + Math.random() * 0.35);
                        const subThickness = mainBranch.thickness * 0.6;
                        
                        tree.branches.push({
                            startHeight: subBranchHeight,
                            angle: subAngle,
                            length: subLength,
                            thickness: subThickness,
                            // Animation
                            swayPhase: Math.random() * Math.PI * 2,
                            swaySpeed: 0.25 + Math.random() * 0.35,
                            swayAmount: 1.2 + Math.random() * 2.2,
                            // Visual effect
                            branchSegments: Math.floor(2 + Math.random() * 2),
                            // Flag as sub-branch for future reference
                            isSubBranch: true
                        });
                    }
                }
            }
        }
        
        // Generate leaves for a data tree
        function generateLeaves(tree) {
            // Create fewer leaves per tree with better distribution
            const numLeafClusters = Math.floor(Math.random() * 4) + 3; // 3-6 leaves per tree (reduced from 4-8)
            
            // Make sure tree has branches before proceeding
            if (tree.branches.length === 0) {
                return; // Skip trees without branches
            }
            
            // Sort branches by their height on the tree - we'll use this to distribute leaves evenly
            const sortedBranches = [...tree.branches].sort((a, b) => a.startHeight - b.startHeight);
            const branchGroups = [];
            
            // Group branches by height sections to ensure better vertical distribution
            const treeHeightSections = 3; // Divide tree into sections
            for (let i = 0; i < treeHeightSections; i++) {
                branchGroups.push([]);
            }
            
            // Assign branches to height groups
            sortedBranches.forEach(branch => {
                const heightPercent = branch.startHeight / tree.height;
                const groupIndex = Math.min(treeHeightSections - 1, Math.floor(heightPercent * treeHeightSections));
                branchGroups[groupIndex].push(branch);
            });
            
            // Create leaves distributed across height sections
            for (let i = 0; i < numLeafClusters; i++) {
                // Determine which height section to place this leaf
                const sectionIndex = i % treeHeightSections;
                let branchGroup = branchGroups[sectionIndex];
                
                // If this section has no branches, find another section
                if (branchGroup.length === 0) {
                    for (let j = 0; j < treeHeightSections; j++) {
                        if (branchGroups[j].length > 0) {
                            branchGroup = branchGroups[j];
                            break;
                        }
                    }
                }
                
                // Skip if no suitable branches found
                if (branchGroup.length === 0) continue;
                
                // Choose a random branch from this group
                const branch = branchGroup[Math.floor(Math.random() * branchGroup.length)];
                
                // Place more naturally along branches - strongly favor tips (outer positions)
                const distanceAlongBranch = 0.6 + Math.random() * 0.4; // 60-100% along branch (outer portion)
                
                const position = {
                    h: branch.startHeight,
                    r: branch.length * distanceAlongBranch,
                    branchAngle: branch.angle
                };
                
                // Vary the angles more dramatically for a natural, artistic spread
                // Leaves should look like they're growing outward from the branch
                // Limiting variation to Â±45 degrees (Ï€/4 radians) for readability
                const angleVariation = (Math.random() - 0.5) * Math.PI * 0.5; // -/+ 45 degrees
                const angle = branch.angle + angleVariation;
                
                // Pick a random leaf image
                const imageIndex = Math.floor(Math.random() * leafImages.length);
                
                // Create leaf with improved positioning properties
                tree.leaves.push({
                    position,
                    angle,
                    size: 45 + Math.random() * 65, // Larger size for better visibility
                    imageIndex,
                    // Animation parameters - limit rotation speed to maintain readability
                    rotationSpeed: (Math.random() - 0.5) * 0.08, // Reduced speed to preserve readability
                    currentRotation: (Math.random() - 0.5) * Math.PI * 0.5, // Initial rotation within Â±45 degrees
                    pulsePhase: Math.random() * Math.PI * 2,
                    // Visual effects
                    opacity: 0.8 + Math.random() * 0.2, // Higher base opacity
                    // Hover animation
                    hoverAmplitude: 5 + Math.random() * 8,
                    hoverFrequency: 0.2 + Math.random() * 0.4, // Slower, more graceful movement
                    // Simplified tint
                    tint: {
                        r: 180 + Math.random() * 75,
                        g: 180 + Math.random() * 75,
                        b: 230 + Math.random() * 25,
                        strength: 0.12 + Math.random() * 0.18 // Reduced tint strength
                    },
                    // Distance from branch - make them stick out more
                    offset: 15 + Math.random() * 35, // Increased offset range
                    // Limit for max rotation to ensure readability
                    maxRotation: Math.PI / 4 // 45 degrees
                });
            }
        }
        
        // Generate digital spirits trapped in tree
        function generateSpirits(tree) {
            for (let i = 0; i < tree.spiritCount; i++) {
                // Position within the tree trunk
                const height = Math.random() * tree.height * 0.7 + tree.height * 0.15;
                const radius = Math.random() * tree.width * 0.4;
                const angle = Math.random() * Math.PI * 2;
                
                // Spirit characteristics
                tree.spirits.push({
                    height,
                    radius,
                    angle,
                    size: 10 + Math.random() * 30,
                    color: {
                        r: 200 + Math.random() * 55,
                        g: 200 + Math.random() * 55,
                        b: 255,
                        a: 0.4 + Math.random() * 0.6
                    },
                    // Animation
                    pulsePhase: Math.random() * Math.PI * 2,
                    pulseSpeed: 1 + Math.random() * 2,
                    orbitSpeed: (Math.random() - 0.5) * 0.3,
                    orbitRadius: radius,
                    // Glow effect
                    glowSize: 1.5 + Math.random() * 2,
                    // Flow pattern - data bits flowing through spirit
                    flowParticles: [],
                    particleCount: Math.floor(Math.random() * 10) + 5
                });
                
                // Create flow particles for this spirit
                const spirit = tree.spirits[i];
                for (let j = 0; j < spirit.particleCount; j++) {
                    spirit.flowParticles.push({
                        offset: Math.random() * 2 * Math.PI,
                        speed: 0.5 + Math.random() * 1.5,
                        size: 1 + Math.random() * 3,
                        distance: Math.random() * spirit.size * 0.8,
                        opacity: 0.5 + Math.random() * 0.5
                    });
                }
            }
        }
        
        // Create connections between trees
        function createConnections() {
            // Clear any existing connections
            connections.length = 0;
            
            // Create more deliberate connections between trees
            // Connect trees that are in adjacent tiers for better visual flow
            for (let i = 0; i < dataTrees.length; i++) {
                const tree = dataTrees[i];
                // Calculate which tier this tree is in
                const treeTier = i % 3;
                
                // Determine number of connections based on tier
                const connectionsCount = treeTier === 0 ? 2 : (treeTier === 1 ? 3 : 1);
                
                // Connect to trees in different tiers for better composition
                const potentialConnections = [];
                
                for (let j = 0; j < dataTrees.length; j++) {
                    if (i === j) continue;
                    
                    const otherTree = dataTrees[j];
                    const otherTier = j % 3;
                    
                    // Prioritize connections between different tiers
                    let connectionPriority = 0;
                    if (treeTier !== otherTier) {
                        // Prefer connecting across adjacent tiers (0->1 or 1->2)
                        connectionPriority = Math.abs(treeTier - otherTier) === 1 ? 3 : 1;
                    } else {
                        // Lower priority for same-tier connections
                        connectionPriority = 0.5;
                    }
                    
                    // Calculate distance for sorting
                    const dx = tree.x - otherTree.x;
                    const dy = tree.y - otherTree.y;
                    const dz = tree.z - otherTree.z;
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    potentialConnections.push({ 
                        index: j, 
                        distance,
                        priority: connectionPriority
                    });
                }
                
                // Sort by priority first, then by distance
                potentialConnections.sort((a, b) => {
                    if (a.priority !== b.priority) {
                        return b.priority - a.priority; // Higher priority first
                    }
                    return a.distance - b.distance; // Then by distance
                });
                
                // Connect to best candidates
                let connectionsAdded = 0;
                for (let k = 0; k < potentialConnections.length && connectionsAdded < connectionsCount; k++) {
                    const targetIndex = potentialConnections[k].index;
                    
                    // Check if connection already exists
                    const connectionExists = connections.some(conn => 
                        (conn.from === i && conn.to === targetIndex) || 
                        (conn.from === targetIndex && conn.to === i)
                    );
                    
                    if (!connectionExists) {
                        // Calculate curve height based on trees' tier difference to keep paths within frame
                        const targetTier = targetIndex % 3;
                        let curveHeight = 50 + Math.random() * 50; // Base curve
                        
                        // Adjust curve direction based on tiers
                        if (treeTier < targetTier) {
                            // Connection going upward (to more distant tier) - curve upward
                            curveHeight *= -1; // Negative makes curve go up
                        } else if (treeTier > targetTier) {
                            // Connection going downward - positive curve value
                        } else {
                            // Same tier - smaller random curve
                            curveHeight = (Math.random() > 0.5 ? 1 : -1) * (20 + Math.random() * 30);
                        }
                        
                        connections.push({
                            from: i,
                            to: targetIndex,
                            // Visual properties
                            width: 1.5 + Math.random() * 1.5, // Thinner connections
                            color: {
                                r: 120 + Math.random() * 50,
                                g: 180 + Math.random() * 75,
                                b: 220 + Math.random() * 35,
                                a: 0.3 + Math.random() * 0.2 // Slightly more transparent
                            },
                            // Animation
                            pulsePhase: Math.random() * Math.PI * 2,
                            pulseSpeed: 0.3 + Math.random() * 0.5, // Slower pulse for better performance
                            // Data packets flowing along the connection
                            dataPackets: [],
                            // How active this connection is
                            activity: 0.15 + Math.random() * 0.15, // Less activity by default
                            // Curve control points
                            curveHeight: curveHeight,
                            curvePhase: Math.random() * Math.PI * 2
                        });
                        
                        // Create initial data packets - fewer for better performance
                        initializeDataPackets(connections[connections.length - 1]);
                        connectionsAdded++;
                    }
                }
            }
        }
        
        // Create data packets for a connection
        function initializeDataPackets(connection) {
            // Fewer packets for performance
            const packetCount = Math.floor(connection.activity * 5) + 1;
            
            for (let i = 0; i < packetCount; i++) {
                connection.dataPackets.push({
                    position: Math.random(), // 0 to 1 along the path
                    speed: 0.08 + Math.random() * 0.12, // Slower for better performance
                    size: 2 + Math.random() * 3, // Slightly smaller
                    // Direction (0 = from->to, 1 = to->from)
                    direction: Math.random() > 0.5 ? 0 : 1,
                    color: {
                        r: connection.color.r + Math.random() * 55,
                        g: connection.color.g + Math.random() * 55,
                        b: connection.color.b + Math.random() * 35,
                        a: 0.5 + Math.random() * 0.3
                    }
                });
            }
        }
        
        // Listen for landmarks data
        socket.on('landmarks', function(data) {
            handLandmarks = JSON.parse(data);
            
            if (handLandmarks && handLandmarks.length > 0) {
                // Get index finger position (usually index 8)
                const indexTip = handLandmarks[8] || handLandmarks[0];
                handPosition = {
                    x: indexTip.x * canvas.width,
                    y: indexTip.y * canvas.height
                };
                
                // Use hand position to control camera offset (parallax effect)
                targetCameraOffset = {
                    x: (handPosition.x - canvas.width / 2) * 0.05,
                    y: (handPosition.y - canvas.height / 2) * 0.05
                };
            }
        });
        
        // Listen for gesture data
        socket.on('gesture', function(data) {
            lastGesture = currentGesture;
            currentGesture = data;
            
            // Handle "Click" gesture to interact with trees and spirits
            if (currentGesture === 'Click' && lastGesture !== 'Click' && handPosition) {
                handleClick();
            }
            
            // Handle "Hold" gesture to control camera movement and disintegrate trees
            if (currentGesture === 'Hold' && handPosition) {
                // Adjust camera Z based on hand position Y
                const targetZ = 1500 + (handPosition.y / canvas.height) * 1000;
                cameraZ += (targetZ - cameraZ) * 0.05;
                
                // Handle tree disintegration
                handleHoldDisintegration();
            }
            
            // Check for transition pattern
            checkTransitionTrigger();
        });
        
        // Variables to track gesture history for transition
        const gestureHistory = [];
        const neededGesturePattern = ['Click', 'Hold', 'Click'];
        const transitionDelay = 1500; // milliseconds
        let lastGestureTime = 0;
        let transitionStarted = false;
        
        // Check if the transition pattern has been completed
        function checkTransitionTrigger() {
            const currentTime = Date.now();
            
            // If it's a new gesture, add it to history
            if (currentGesture !== lastGesture) {
                // Reset if too much time has passed since last gesture
                if (currentTime - lastGestureTime > 2000 && gestureHistory.length > 0) {
                    gestureHistory.length = 0;
                    updateTransitionIndicator();
                }
                
                // Add new gesture to history
                gestureHistory.push(currentGesture);
                // Keep only the most recent gestures that match the pattern length
                if (gestureHistory.length > neededGesturePattern.length) {
                    gestureHistory.shift();
                }
                
                lastGestureTime = currentTime;
                
                // Update the visual indicator
                updateTransitionIndicator();
                
                // Check if pattern is complete
                let patternMatch = true;
                if (gestureHistory.length === neededGesturePattern.length) {
                    for (let i = 0; i < neededGesturePattern.length; i++) {
                        if (gestureHistory[i] !== neededGesturePattern[i]) {
                            patternMatch = false;
                            break;
                        }
                    }
                    
                    // If pattern matches and transition hasn't started yet
                    if (patternMatch && !transitionStarted) {
                        startTransition();
                    }
                }
            }
        }
        
        // Update the visual indicator for transition progress
        function updateTransitionIndicator() {
            for (let i = 0; i < neededGesturePattern.length; i++) {
                const dotElement = document.getElementById(`gesture-${i+1}`);
                
                if (i < gestureHistory.length) {
                    dotElement.classList.add('active');
                    // Add gesture-specific class
                    if (gestureHistory[i] === 'Click') {
                        dotElement.classList.add('click');
                        dotElement.classList.remove('hold');
                    } else if (gestureHistory[i] === 'Hold') {
                        dotElement.classList.add('hold');
                        dotElement.classList.remove('click');
                    }
                } else {
                    dotElement.classList.remove('active', 'click', 'hold');
                }
            }
        }
        
        // Begin transition to next scene
        function startTransition() {
            transitionStarted = true;
            
            // Create a dramatic visual effect
            for (let i = 0; i < dataTrees.length; i++) {
                // Schedule disintegration of all trees with slight delays
                setTimeout(() => {
                    if (i < dataTrees.length) {
                        disintegrateTree(dataTrees[i], i);
                    }
                }, i * 100); // Stagger by 100ms
            }
            
            // Create big binary burst effect at center
            setTimeout(() => {
                const centerX = 0;
                const centerY = 0;
                const centerZ = 0;
                createBinaryBurstEffect(centerX, centerY, centerZ, 200);
                
                // Create white flash effect
                createWhiteFlash();
            }, dataTrees.length * 100 + 500);
            
            // Redirect to next scene after visual effects
            setTimeout(() => {
                window.location.href = '/scene-five';
            }, dataTrees.length * 100 + transitionDelay);
        }
        
        // Create white flash effect for transition
        function createWhiteFlash() {
            const flashOverlay = document.createElement('div');
            flashOverlay.style.position = 'fixed';
            flashOverlay.style.top = 0;
            flashOverlay.style.left = 0;
            flashOverlay.style.width = '100%';
            flashOverlay.style.height = '100%';
            flashOverlay.style.backgroundColor = 'white';
            flashOverlay.style.opacity = 0;
            flashOverlay.style.zIndex = 1000;
            flashOverlay.style.transition = 'opacity 0.5s ease-in-out';
            
            document.body.appendChild(flashOverlay);
            
            // Fade in
            setTimeout(() => {
                flashOverlay.style.opacity = 1;
            }, 10);
            
            // Fade out slowly
            setTimeout(() => {
                flashOverlay.style.opacity = 0;
            }, 800);
        }
        
        // Particle system for tree disintegration
        const disintegrationParticles = [];
        
        // Handle Hold gesture to disintegrate trees
        function handleHoldDisintegration() {
            if (!handPosition) return;
            
            // Define disintegration radius - area affected by the Hold gesture
            const disintegrationRadius = 120;
            
            // Find trees within disintegration radius
            for (let i = dataTrees.length - 1; i >= 0; i--) {
                const tree = dataTrees[i];
                
                // Project tree position to screen
                const treeProj = project3D(tree.x, tree.y, tree.z);
                
                // Calculate 2D distance on screen from hand position
                const dx = treeProj.x - handPosition.x;
                const dy = treeProj.y - handPosition.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // If tree is within disintegration radius, start disintegrating it
                if (distance < disintegrationRadius) {
                    // Create disintegration effect
                    disintegrateTree(tree, i);
                    
                    // Remove tree from array
                    dataTrees.splice(i, 1);
                    
                    // Recalculate connections after removing a tree
                    createConnections();
                    
                    // Only disintegrate one tree per frame for better performance
                    break;
                }
            }
        }
        
        // Create disintegration effect for a tree
        function disintegrateTree(tree, treeIndex) {
            // Number of particles based on tree size
            const particleCount = Math.floor(tree.height * tree.width / 200);
            
            // Create binary code particles for trunk
            for (let i = 0; i < particleCount; i++) {
                // Random position within tree trunk
                const heightPercent = Math.random();
                const y = tree.y - tree.height * heightPercent;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * tree.width * 0.5;
                
                const x = tree.x + Math.cos(angle) * radius;
                const z = tree.z + Math.sin(angle) * radius;
                
                // Create binary digit
                createBinaryAshParticle(x, y, z, tree.color);
            }
            
            // Create particles for each branch
            tree.branches.forEach(branch => {
                const branchY = tree.y - branch.startHeight;
                const branchX = tree.x + Math.cos(branch.angle) * branch.length * 0.5;
                const branchZ = tree.z + Math.sin(branch.angle) * branch.length * 0.5;
                
                for (let i = 0; i < Math.floor(branch.length / 20); i++) {
                    createBinaryAshParticle(
                        branchX + (Math.random() - 0.5) * branch.length * 0.3,
                        branchY + (Math.random() - 0.5) * 20,
                        branchZ + (Math.random() - 0.5) * branch.length * 0.3,
                        tree.color
                    );
                }
            });
            
            // Create particles for each spirit
            tree.spirits.forEach(spirit => {
                const spiritY = tree.y - spirit.height;
                const spiritX = tree.x + Math.cos(spirit.angle) * spirit.radius;
                const spiritZ = tree.z + Math.sin(spirit.angle) * spirit.radius;
                
                // Create glowing particles for spirit
                for (let i = 0; i < 10; i++) {
                    createGlowingAshParticle(
                        spiritX + (Math.random() - 0.5) * 30,
                        spiritY + (Math.random() - 0.5) * 30,
                        spiritZ + (Math.random() - 0.5) * 30,
                        spirit.color
                    );
                }
            });
            
            // Create particles for each leaf
            tree.leaves.forEach(leaf => {
                const leafPos = getLeafPosition(tree, leaf);
                createGlowingAshParticle(leafPos.x, leafPos.y, leafPos.z, {
                    r: 100 + Math.random() * 50,
                    g: 180 + Math.random() * 50,
                    b: 220 + Math.random() * 35,
                    a: 0.8
                });
            });
            
            // Play disintegration sound or effect if needed
            // ...
        }
        
        // Handle click interaction with trees and spirits
        function handleClick() {
            if (!handPosition) return;
            
            // Convert screen position to world space for hit testing
            // This is an approximate conversion - fix the scaling to better match finger position
            const worldX = (handPosition.x - canvas.width/2) / (cameraZ / 1000);
            const worldY = (handPosition.y - canvas.height/2) / (cameraZ / 1000);
            
            // Find closest tree/spirit to interact with
            let closestTree = null;
            let closestDistance = Infinity;
            
            // Check each tree
            dataTrees.forEach(tree => {
                // Project tree position to screen
                const treeProj = project3D(tree.x, tree.y, tree.z);
                
                // Calculate 2D distance on screen
                const dx = treeProj.x - handPosition.x;
                const dy = treeProj.y - handPosition.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // Scale hit area based on tree's projected size
                const hitRadius = tree.width * treeProj.factor * 1.5;
                
                // Check if this is the closest tree within hit range
                if (distance < hitRadius && distance < closestDistance) {
                    closestTree = tree;
                    closestDistance = distance;
                }
            });
            
            // If we found a tree to interact with
            if (closestTree) {
                interactWithTree(closestTree);
            } else {
                // If no tree was clicked, plant a new tree at finger position
                // Use a more direct planting approach for better accuracy
                plantDigitalSeedAtScreen(handPosition.x, handPosition.y);
            }
        }
        
        // Plant a digital seed directly using screen coordinates
        function plantDigitalSeedAtScreen(screenX, screenY) {
            // Calculate depth based on Y position (higher on screen = further away)
            const depthFactor = screenY / canvas.height; // 0 at top, 1 at bottom
            const z = 800 - depthFactor * 400; // 400 at top of screen, 800 at bottom
            
            // Reverse the 3D projection to get world coordinates
            const cameraFactor = cameraZ / (z + cameraZ);
            const worldX = (screenX - canvas.width/2 - cameraOffset.x) / cameraFactor;
            const worldY = (screenY - canvas.height/2 - cameraOffset.y) / cameraFactor;
            
            // Plant the seed at the calculated world position
            plantDigitalSeed(worldX, worldY, z);
        }
        
        // Plant a digital seed that grows into a tree with explicit z coordinate
        const digitalSeeds = [];
        function plantDigitalSeed(x, y, z = null) {
            // If z is not provided, calculate it based on distance from center with some randomness
            if (z === null) {
                z = (Math.random() - 0.5) * 400 + 600;
            }
            
            // Create a new seed
            const seed = {
                id: dataTrees.length,
                x: x,
                y: y,
                z: z,
                growthStage: 0, // 0 = seed, 1 = sapling, 2 = full tree
                growthRate: 0.5 + Math.random() * 0.5,
                pulsePhase: Math.random() * Math.PI * 2,
                growthProgress: 0,
                // Final tree parameters (will be used when fully grown)
                finalHeight: 200 + Math.random() * 150,
                finalWidth: 30 + Math.random() * 20,
                color: {
                    r: 40 + Math.random() * 40,
                    g: 80 + Math.random() * 70,
                    b: 150 + Math.random() * 60,
                    a: 0.4 + Math.random() * 0.3
                },
                // Glitch effect parameters
                glitchIntensity: 1.0,
                glitchPhase: Math.random() * Math.PI * 2,
                glitchSegments: 3 + Math.floor(Math.random() * 5),
                // Growth particles
                particles: []
            };
            
            // Create initial growth particles
            for (let i = 0; i < 15; i++) {
                seed.particles.push({
                    x: 0,
                    y: 0,
                    z: 0,
                    speed: 5 + Math.random() * 15,
                    angle: Math.random() * Math.PI * 2,
                    verticalSpeed: -10 - Math.random() * 20,
                    size: 2 + Math.random() * 3,
                    opacity: 0.7 + Math.random() * 0.3,
                    life: 1.0,
                    color: {
                        r: seed.color.r + 80 + Math.random() * 40,
                        g: seed.color.g + 100 + Math.random() * 40,
                        b: seed.color.b + 100 + Math.random() * 40
                    }
                });
            }
            
            // Add to seeds array
            digitalSeeds.push(seed);
            
            // Create binary code particles for artistic effect
            createBinaryBurstEffect(x, y, z, 20);
        }
        
        // Function to create binary code burst effect
        function createBinaryBurstEffect(x, y, z, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 20 + Math.random() * 80;
                
                const digit = Math.random() > 0.5 ? "1" : "0";
                const size = 10 + Math.random() * 15;
                
                releaseParticles.push({
                    x, y, z,
                    dirX: Math.cos(angle) * (Math.random() * 0.8 + 0.2),
                    dirY: Math.sin(angle) * (Math.random() * 0.8 + 0.2) - Math.random() * 0.5, // Bias upward
                    dirZ: Math.sin(angle) * (Math.random() * 0.8 + 0.2),
                    speed: speed,
                    size: size,
                    text: digit,
                    color: {
                        r: 100 + Math.random() * 155,
                        g: 200 + Math.random() * 55,
                        b: 255,
                        a: 0.8 + Math.random() * 0.2
                    },
                    life: 1 + Math.random() * 1.5,
                    gravity: 5 + Math.random() * 5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 2
                });
            }
        }
        
        // Create a binary code ash particle
        function createBinaryAshParticle(x, y, z, baseColor) {
            const isBinary = Math.random() > 0.3;
            
            if (isBinary) {
                // Binary digit particle (0 or 1)
                const digit = Math.random() > 0.5 ? "1" : "0";
                
                disintegrationParticles.push({
                    x, y, z,
                    dirX: (Math.random() - 0.5) * 2,
                    dirY: -Math.random() * 3 - 1, // Mostly upward
                    dirZ: (Math.random() - 0.5) * 2,
                    speed: 20 + Math.random() * 50,
                    size: 10 + Math.random() * 15,
                    text: digit,
                    color: {
                        r: baseColor.r + 50 + Math.random() * 80,
                        g: baseColor.g + 70 + Math.random() * 60,
                        b: baseColor.b + 100 + Math.random() * 50,
                        a: 0.8 + Math.random() * 0.2
                    },
                    life: 1 + Math.random() * 2,
                    gravity: 2 + Math.random() * 5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 3
                });
            } else {
                // Regular ash particle
                disintegrationParticles.push({
                    x, y, z,
                    dirX: (Math.random() - 0.5) * 2,
                    dirY: -Math.random() * 2 - 0.5,
                    dirZ: (Math.random() - 0.5) * 2,
                    speed: 10 + Math.random() * 40,
                    size: 3 + Math.random() * 5,
                    color: {
                        r: baseColor.r + 30 + Math.random() * 40,
                        g: baseColor.g + 50 + Math.random() * 40,
                        b: baseColor.b + 70 + Math.random() * 40,
                        a: 0.6 + Math.random() * 0.4
                    },
                    life: 1 + Math.random() * 1.5,
                    gravity: 1 + Math.random() * 3
                });
            }
        }
        
        // Create a glowing ash particle (for spirits and leaves)
        function createGlowingAshParticle(x, y, z, color) {
            disintegrationParticles.push({
                x, y, z,
                dirX: (Math.random() - 0.5) * 3,
                dirY: -Math.random() * 3 - 1,
                dirZ: (Math.random() - 0.5) * 3,
                speed: 30 + Math.random() * 60,
                size: 5 + Math.random() * 10,
                glow: true,
                color: {
                    r: color.r + Math.random() * 30,
                    g: color.g + Math.random() * 30,
                    b: color.b + Math.random() * 30,
                    a: color.a || 0.8
                },
                life: 1.5 + Math.random() * 2,
                gravity: 0.5 + Math.random() * 2
            });
        }
        
        // Update and draw disintegration particles
        function updateDisintegrationParticles() {
            for (let i = disintegrationParticles.length - 1; i >= 0; i--) {
                const particle = disintegrationParticles[i];
                
                // Update position
                particle.x += particle.dirX * particle.speed * deltaTime;
                particle.y += particle.dirY * particle.speed * deltaTime;
                particle.z += particle.dirZ * particle.speed * deltaTime;
                
                // Apply gravity
                particle.dirY += particle.gravity * deltaTime;
                
                // Update life
                particle.life -= deltaTime;
                
                // Remove if expired
                if (particle.life <= 0) {
                    disintegrationParticles.splice(i, 1);
                    continue;
                }
                
                // Draw particle
                const proj = project3D(particle.x, particle.y, particle.z);
                const size = particle.size * proj.factor;
                
                // Fade out as life decreases
                const alpha = particle.color.a * (particle.life / 2);
                
                if (particle.text) {
                    // Update rotation for text particles
                    if (particle.rotationSpeed) {
                        particle.rotation += particle.rotationSpeed * deltaTime;
                    }
                    
                    // Draw text
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(particle.rotation);
                    
                    ctx.font = `${Math.floor(size)}px monospace`;
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(particle.text, 0, 0);
                    
                    ctx.restore();
                } else if (particle.glow) {
                    // Draw glowing particle
                    // Main particle
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`;
                    ctx.fill();
                    
                    // Glow effect
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size * 3, 0, Math.PI * 2);
                    const glowGradient = ctx.createRadialGradient(
                        proj.x, proj.y, size * 0.5,
                        proj.x, proj.y, size * 3
                    );
                    glowGradient.addColorStop(0, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha * 0.7})`);
                    glowGradient.addColorStop(1, `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, 0)`);
                    
                    ctx.fillStyle = glowGradient;
                    ctx.fill();
                } else {
                    // Regular particle
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`;
                    ctx.fill();
                    
                    // Simple glow
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha * 0.3})`;
                    ctx.fill();
                }
            }
        }
        
        // Handle interaction with a specific tree
        function interactWithTree(tree) {
            // Toggle selection state
            tree.isSelected = !tree.isSelected;
            
            // Increase glow intensity when selected
            if (tree.isSelected) {
                tree.glowIntensity = 2.0;
                
                // Release spirits - animate them floating out more actively
                tree.spirits.forEach(spirit => {
                    spirit.orbitSpeed *= 3;
                    spirit.pulseSpeed *= 2;
                    
                    // Make flow particles more active
                    spirit.flowParticles.forEach(particle => {
                        particle.speed *= 2;
                        particle.distance *= 1.5;
                    });
                });
                
                // Animate leaves - make them "flutter"
                tree.leaves.forEach(leaf => {
                    leaf.rotationSpeed *= 3;
                    leaf.hoverAmplitude *= 2;
                    leaf.hoverFrequency *= 1.5;
                });
                
                // Create some particle effects for feedback
                for (let i = 0; i < 20; i++) {
                    createReleaseParticle(tree);
                }
            } else {
                // Reset to normal state
                tree.glowIntensity = 0.5 + Math.random() * 0.5;
                
                // Calm spirits down
                tree.spirits.forEach(spirit => {
                    spirit.orbitSpeed /= 3;
                    spirit.pulseSpeed /= 2;
                    
                    // Reset flow particles
                    spirit.flowParticles.forEach(particle => {
                        particle.speed /= 2;
                        particle.distance /= 1.5;
                    });
                });
                
                // Reset leaf animation
                tree.leaves.forEach(leaf => {
                    leaf.rotationSpeed /= 3;
                    leaf.hoverAmplitude /= 2;
                    leaf.hoverFrequency /= 1.5;
                });
            }
            
            // Activate connections from this tree
            connections.forEach(conn => {
                if (conn.from === tree.id || conn.to === tree.id) {
                    // Increase connection activity
                    conn.activity = tree.isSelected ? 0.9 : 0.3;
                    
                    // Add more data packets when activated
                    if (tree.isSelected) {
                        const newPackets = Math.floor(Math.random() * 5) + 3;
                        for (let i = 0; i < newPackets; i++) {
                            conn.dataPackets.push({
                                position: Math.random(),
                                speed: 0.3 + Math.random() * 0.5,
                                size: 3 + Math.random() * 4,
                                direction: Math.random() > 0.5 ? 0 : 1,
                                color: {
                                    r: conn.color.r + Math.random() * 55,
                                    g: conn.color.g + Math.random() * 55,
                                    b: conn.color.b + Math.random() * 35,
                                    a: 0.7 + Math.random() * 0.3
                                }
                            });
                        }
                    } else {
                        // Reduce data packets when deactivated
                        conn.dataPackets = conn.dataPackets.slice(0, Math.max(1, Math.floor(conn.dataPackets.length / 2)));
                    }
                }
            });
        }
        
        // Spirit release particles system
        const releaseParticles = [];
        
        // Create particles when a spirit is released/activated
        function createReleaseParticle(tree) {
            // Random position within the tree
            const height = Math.random() * tree.height;
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * tree.width * 0.5;
            
            const x = tree.x + Math.cos(angle) * radius;
            const y = tree.y - height;
            const z = tree.z + Math.sin(angle) * radius;
            
            // Random direction outward from tree center
            const dirX = Math.cos(angle);
            const dirY = -0.5 - Math.random() * 0.5; // Mostly upward
            const dirZ = Math.sin(angle);
            
            releaseParticles.push({
                x, y, z,
                dirX, dirY, dirZ,
                speed: 20 + Math.random() * 80,
                size: 3 + Math.random() * 7,
                color: {
                    r: 200 + Math.random() * 55,
                    g: 200 + Math.random() * 55,
                    b: 255,
                    a: 0.6 + Math.random() * 0.4
                },
                life: 1 + Math.random() * 2, // seconds
                gravity: 5 + Math.random() * 10
            });
        }
        
        // Update and draw release particles
        function updateReleaseParticles() {
            for (let i = releaseParticles.length - 1; i >= 0; i--) {
                const particle = releaseParticles[i];
                
                // Update position
                particle.x += particle.dirX * particle.speed * deltaTime;
                particle.y += particle.dirY * particle.speed * deltaTime;
                particle.z += particle.dirZ * particle.speed * deltaTime;
                
                // Apply gravity
                particle.dirY += particle.gravity * deltaTime;
                
                // Update life
                particle.life -= deltaTime;
                
                // Remove if expired
                if (particle.life <= 0) {
                    releaseParticles.splice(i, 1);
                    continue;
                }
                
                // Draw particle
                const proj = project3D(particle.x, particle.y, particle.z);
                const size = particle.size * proj.factor;
                
                // Fade out as life decreases
                const alpha = particle.color.a * (particle.life / 3);
                
                // Check if this is a text particle (binary) or regular particle
                if (particle.text) {
                    // Update rotation
                    particle.rotation += particle.rotationSpeed * deltaTime;
                    
                    // Draw text
                    ctx.save();
                    ctx.translate(proj.x, proj.y);
                    ctx.rotate(particle.rotation);
                    
                    ctx.font = `${Math.floor(size)}px monospace`;
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(particle.text, 0, 0);
                    
                    ctx.restore();
                } else {
                    // Draw regular particle
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`;
                    ctx.fill();
                    
                    // Add glow
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha * 0.3})`;
                    ctx.fill();
                }
            }
        }
        
        // Update digital seeds growth
        function updateDigitalSeeds() {
            for (let i = digitalSeeds.length - 1; i >= 0; i--) {
                const seed = digitalSeeds[i];
                
                // Update growth progress
                seed.growthProgress += seed.growthRate * deltaTime;
                
                // Update growth stage based on progress
                if (seed.growthProgress >= 1.0 && seed.growthStage === 0) {
                    // Transition from seed to sapling
                    seed.growthStage = 1;
                    seed.growthProgress = 0;
                    
                    // More growth particles when reaching sapling stage
                    createBinaryBurstEffect(seed.x, seed.y - 50, seed.z, 15);
                } else if (seed.growthProgress >= 1.0 && seed.growthStage === 1) {
                    // Transition from sapling to full tree
                    seed.growthStage = 2;
                    
                    // Convert to a full tree and add to dataTrees
                    const newTree = {
                        id: seed.id,
                        x: seed.x,
                        y: seed.y,
                        z: seed.z,
                        height: seed.finalHeight,
                        width: seed.finalWidth,
                        color: seed.color,
                        // Animation parameters
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.08, // Slower, more elegant rotation
                        pulsePhase: seed.pulsePhase,
                        hoverOffset: 0,
                        // Tree characteristics
                        branches: [],
                        leaves: [],
                        // Ghost effect 
                        ghostLayers: 2 + Math.floor(Math.random() * 3),
                        ghostAlpha: 0.25 + Math.random() * 0.3, // Slightly more visible ghost effect
                        // Digital "spirits" trapped in the tree
                        spirits: [],
                        spiritCount: Math.floor(Math.random() * 4) + 2, // Slightly fewer spirits for cleaner look
                        // Interaction state
                        isSelected: false,
                        selectionIntensity: 0,
                        // Light effects
                        glowIntensity: 0.6 + Math.random() * 0.5, // Increased base glow
                        glowColor: {
                            r: 150 + Math.random() * 50,
                            g: 200 + Math.random() * 55,
                            b: 255,
                        }
                    };
                    
                    // Generate branches, leaves, and spirits with artistic spacing
                    generateBranches(newTree);
                    generateLeaves(newTree); // This will use our improved leaf distribution
                    generateSpirits(newTree);
                    
                    // Add to trees array
                    dataTrees.push(newTree);
                    
                    // Final growth burst
                    createBinaryBurstEffect(seed.x, seed.y - seed.finalHeight/2, seed.z, 30);
                    
                    // Remove seed
                    digitalSeeds.splice(i, 1);
                    
                    // Update connections
                    createConnections();
                    continue;
                }
                
                // Update seed particles
                for (let j = seed.particles.length - 1; j >= 0; j--) {
                    const particle = seed.particles[j];
                    
                    // Update position based on current growth stage
                    if (seed.growthStage === 0) {
                        // Seed stage - particles converge and hover
                        particle.x += Math.cos(particle.angle) * particle.speed * deltaTime;
                        particle.y += particle.verticalSpeed * deltaTime;
                        particle.z += Math.sin(particle.angle) * particle.speed * deltaTime;
                        
                        // Reduce outward speed
                        particle.speed *= 0.95;
                        particle.verticalSpeed *= 0.95;
                        
                        // Reduce life
                        particle.life -= deltaTime * 0.5;
                    } else if (seed.growthStage === 1) {
                        // Sapling stage - particles move upward
                        particle.verticalSpeed = -30 - Math.random() * 20;
                        particle.y += particle.verticalSpeed * deltaTime;
                        
                        // Reduce life faster
                        particle.life -= deltaTime;
                    }
                    
                    // Remove dead particles
                    if (particle.life <= 0) {
                        seed.particles.splice(j, 1);
                        continue;
                    }
                    
                    // Create new particles if needed
                    if (seed.particles.length < 10 && Math.random() < 0.1) {
                        seed.particles.push({
                            x: 0,
                            y: 0,
                            z: 0,
                            speed: 5 + Math.random() * 15,
                            angle: Math.random() * Math.PI * 2,
                            verticalSpeed: -10 - Math.random() * 20,
                            size: 2 + Math.random() * 3,
                            opacity: 0.7 + Math.random() * 0.3,
                            life: 1.0,
                            color: {
                                r: seed.color.r + 80 + Math.random() * 40,
                                g: seed.color.g + 100 + Math.random() * 40,
                                b: seed.color.b + 100 + Math.random() * 40
                            }
                        });
                    }
                }
            }
        }
        
        // Draw digital seeds in different growth stages
        function drawDigitalSeeds() {
            digitalSeeds.forEach(seed => {
                // Project position
                const baseProj = project3D(seed.x, seed.y, seed.z);
                
                // Apply glitch effect timing
                const glitchTime = time * 3 + seed.glitchPhase;
                const glitchOffset = seed.glitchIntensity * (1.0 - seed.growthProgress * 0.3);
                
                if (seed.growthStage === 0) {
                    // Draw seed stage - a small glitching sphere
                    const seedSize = 5 + seed.growthProgress * 15;
                    const pulse = Math.sin(time * 3 + seed.pulsePhase) * 0.2 + 0.8;
                    
                    // Draw glitched seed with segments
                    for (let i = 0; i < seed.glitchSegments; i++) {
                        const segmentAngle = (i / seed.glitchSegments) * Math.PI * 2;
                        const offsetX = Math.sin(glitchTime + segmentAngle) * glitchOffset * seedSize * 0.3;
                        const offsetY = Math.cos(glitchTime + segmentAngle) * glitchOffset * seedSize * 0.3;
                        
                        ctx.beginPath();
                        ctx.arc(
                            baseProj.x + offsetX, 
                            baseProj.y + offsetY, 
                            seedSize * baseProj.factor * pulse, 
                            segmentAngle, 
                            segmentAngle + (Math.PI * 2 / seed.glitchSegments)
                        );
                        ctx.lineTo(baseProj.x, baseProj.y);
                        ctx.closePath();
                        
                        // Use gradient fill
                        const gradient = ctx.createRadialGradient(
                            baseProj.x, baseProj.y, 0,
                            baseProj.x, baseProj.y, seedSize * baseProj.factor
                        );
                        gradient.addColorStop(0, `rgba(${seed.color.r + 100}, ${seed.color.g + 100}, ${seed.color.b + 100}, ${seed.color.a * pulse})`);
                        gradient.addColorStop(1, `rgba(${seed.color.r}, ${seed.color.g}, ${seed.color.b}, ${seed.color.a * 0.5 * pulse})`);
                        
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // Draw segment borders for digital look
                        ctx.strokeStyle = `rgba(${seed.color.r + 100}, ${seed.color.g + 150}, ${seed.color.b + 150}, ${seed.color.a * pulse})`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                    
                    // Add a data core in the center
                    ctx.beginPath();
                    ctx.arc(baseProj.x, baseProj.y, seedSize * 0.3 * baseProj.factor, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(200, 230, 255, ${0.7 * pulse})`;
                    ctx.fill();
                } else if (seed.growthStage === 1) {
                    // Draw sapling stage - taller, thin structure with branching beginning
                    const saplingHeight = seed.finalHeight * 0.6 * seed.growthProgress;
                    const saplingWidth = seed.finalWidth * 0.5;
                    
                    // Project top position
                    const topY = seed.y - saplingHeight;
                    const topProj = project3D(seed.x, topY, seed.z);
                    
                    // Calculate scaled width
                    const scaledWidth = saplingWidth * baseProj.factor;
                    
                    // Draw stylized sapling trunk with glitch segments
                    for (let i = 0; i < seed.glitchSegments; i++) {
                        const heightSegment = i / seed.glitchSegments;
                        const nextHeightSegment = (i + 1) / seed.glitchSegments;
                        
                        // Calculate segment points with glitch offset
                        const segStartY = seed.y - saplingHeight * heightSegment;
                        const segEndY = seed.y - saplingHeight * nextHeightSegment;
                        
                        const glitchOffsetX = Math.sin(glitchTime * (1 + heightSegment) + i) * glitchOffset * 10;
                        
                        const segStartProj = project3D(
                            seed.x + glitchOffsetX * heightSegment, 
                            segStartY, 
                            seed.z
                        );
                        const segEndProj = project3D(
                            seed.x + glitchOffsetX * nextHeightSegment, 
                            segEndY, 
                            seed.z
                        );
                        
                        // Width varies along height
                        const startWidth = scaledWidth * (1 - heightSegment * 0.3);
                        const endWidth = scaledWidth * (1 - nextHeightSegment * 0.4);
                        
                        // Draw segment
                        ctx.beginPath();
                        ctx.moveTo(segStartProj.x - startWidth/2, segStartProj.y);
                        ctx.lineTo(segStartProj.x + startWidth/2, segStartProj.y);
                        ctx.lineTo(segEndProj.x + endWidth/2, segEndProj.y);
                        ctx.lineTo(segEndProj.x - endWidth/2, segEndProj.y);
                        ctx.closePath();
                        
                        // Create gradient
                        const gradient = ctx.createLinearGradient(
                            segStartProj.x, segStartProj.y,
                            segEndProj.x, segEndProj.y
                        );
                        gradient.addColorStop(0, `rgba(${seed.color.r}, ${seed.color.g}, ${seed.color.b}, ${seed.color.a})`);
                        gradient.addColorStop(1, `rgba(${seed.color.r + 20}, ${seed.color.g + 30}, ${seed.color.b + 50}, ${seed.color.a * 0.7})`);
                        
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        // Digital edge effect
                        ctx.strokeStyle = `rgba(${seed.color.r + 50}, ${seed.color.g + 100}, ${seed.color.b + 120}, 0.6)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Digital circuit lines along trunk
                        if (i % 2 === 0) {
                            ctx.beginPath();
                            ctx.moveTo(segStartProj.x, segStartProj.y);
                            ctx.lineTo(segEndProj.x, segEndProj.y);
                            ctx.strokeStyle = `rgba(150, 220, 255, 0.6)`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    }
                    
                    // Draw a few proto-branches
                    const numProtoBranches = 2 + Math.floor(seed.growthProgress * 3);
                    for (let i = 0; i < numProtoBranches; i++) {
                        const heightPercent = 0.5 + (i / numProtoBranches) * 0.5;
                        const branchY = seed.y - saplingHeight * heightPercent;
                        const branchProj = project3D(seed.x, branchY, seed.z);
                        
                        const angle = (i / numProtoBranches) * Math.PI * 2;
                        const length = scaledWidth * (1 + seed.growthProgress);
                        
                        const endX = branchProj.x + Math.cos(angle) * length;
                        const endY = branchProj.y + Math.sin(angle) * length * 0.3;
                        
                        // Draw branch with digital effect
                        ctx.beginPath();
                        ctx.moveTo(branchProj.x, branchProj.y);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = `rgba(${seed.color.r + 40}, ${seed.color.g + 70}, ${seed.color.b + 90}, 0.7)`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // Add small glow
                        ctx.shadowColor = `rgba(150, 220, 255, 0.5)`;
                        ctx.shadowBlur = 5;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Draw particles for all stages
                seed.particles.forEach(particle => {
                    const particleX = seed.x + particle.x;
                    const particleY = seed.y + particle.y;
                    const particleZ = seed.z + particle.z;
                    
                    const particleProj = project3D(particleX, particleY, particleZ);
                    const size = particle.size * particleProj.factor;
                    
                    // Fade based on life
                    const alpha = particle.opacity * particle.life;
                    
                    // Draw particle
                    ctx.beginPath();
                    ctx.arc(particleProj.x, particleProj.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha})`;
                    ctx.fill();
                    
                    // Add glow
                    ctx.beginPath();
                    ctx.arc(particleProj.x, particleProj.y, size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${alpha * 0.3})`;
                    ctx.fill();
                });
            });
        }
        
        // Main animation loop
        function animate(currentTime) {
            requestAnimationFrame(animate);
            
            // Calculate delta time for smooth animations
            if (!lastFrameTime) lastFrameTime = currentTime;
            deltaTime = (currentTime - lastFrameTime) / 1000; // in seconds
            lastFrameTime = currentTime;
            
            // Cap deltaTime to prevent jumps after tab switch
            if (deltaTime > 0.1) deltaTime = 0.1;
            
            // Update time for animations
            time += deltaTime;
            
            // Smooth camera movement
            cameraOffset.x += (targetCameraOffset.x - cameraOffset.x) * 0.05;
            cameraOffset.y += (targetCameraOffset.y - cameraOffset.y) * 0.05;
            
            // Clear the canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw starry background with parallax effect
            drawBackground();
            updateShootingStars();
            
            // Sort trees by z-position for proper rendering order
            const sortedTrees = [...dataTrees].sort((a, b) => (b.z - a.z));
            
            // Draw connections between trees (drawn first so they're behind trees)
            drawConnections();
            
            // Draw data trees
            sortedTrees.forEach(tree => {
                drawTree(tree);
            });
            
            // Update and draw release particles
            updateReleaseParticles();
            
            // Update and draw digital seeds
            updateDigitalSeeds();
            drawDigitalSeeds();
            
            // Update and draw disintegration particles
            updateDisintegrationParticles();
            
            // Draw hand landmarks if available (for debugging/feedback)
            if (handLandmarks && handLandmarks.length > 0) {
                drawHandLandmarks();
            }
            
            // Create occasional shooting stars for better ambience in empty forest
            if (dataTrees.length === 0 && Math.random() < 0.02) {
                createShootingStar();
            }
        }
        
        // Draw starry background with parallax effect
        function drawBackground() {
            // Clear with gradient
            const gradient = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, 0,
                canvas.width / 2, canvas.height / 2, canvas.height
            );
            gradient.addColorStop(0, 'rgba(10, 20, 40, 1)');
            gradient.addColorStop(1, 'rgba(0, 0, 10, 1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars with 3D parallax effect
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                
                // Project star position with camera offset
                const projection = project3D(star.x, star.y, star.z);
                
                // Only draw stars in view
                if (projection.x > -50 && projection.x < canvas.width + 50 &&
                    projection.y > -50 && projection.y < canvas.height + 50) {
                    
                    // Size based on distance
                    const size = star.radius * projection.factor * 2;
                    
                    // Twinkle effect
                    const twinkle = Math.sin(time * 3 + i * 0.3) * 0.15 + 0.85;
                    const alpha = star.color.a * twinkle;
                    
                    // Draw star with glow
                    ctx.beginPath();
                    ctx.arc(projection.x, projection.y, size, 0, Math.PI * 2);
                    const color = star.color;
                    ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha})`;
                    ctx.fill();
                    
                    // Add glow for brighter stars
                    if (size > 1) {
                        ctx.beginPath();
                        ctx.arc(projection.x, projection.y, size * 2, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${alpha * 0.2})`;
                        ctx.fill();
                    }
                }
            }
            
            // Draw constellation patterns
            drawConstellations();
            
            // Occasional shooting star
            if (Math.random() < 0.005) {
                createShootingStar();
            }
        }
        
        // Draw constellation patterns similar to hand tracking visuals
        function drawConstellations() {
            // Colors for nodes
            const nodeColors = {
                blue: {
                    fill: 'rgba(100, 180, 255, 0.7)',
                    glow: 'rgba(60, 150, 255, 0.3)'
                },
                gold: {
                    fill: 'rgba(255, 215, 0, 0.7)',
                    glow: 'rgba(255, 190, 0, 0.3)'
                }
            };
            
            // Draw each constellation
            constellations.forEach(constellation => {
                const stars = constellation.stars;
                const connections = constellation.connections;
                
                // Calculate pulse effect for connection opacity
                const connectionPulse = Math.sin(time * constellation.pulseSpeed + constellation.pulsePhase) * 0.2 + 0.8;
                
                // Draw connections first
                ctx.lineWidth = 1;
                ctx.lineCap = 'round';
                
                // Draw connections between stars
                for (const [i, j] of connections) {
                    if (i >= stars.length || j >= stars.length) continue;
                    
                    // Project star positions
                    const starA = stars[i];
                    const starB = stars[j];
                    const projA = project3D(starA.x, starA.y, starA.z);
                    const projB = project3D(starB.x, starB.y, starB.z);
                    
                    // Skip if either star is behind camera
                    if (starA.z + cameraZ <= 0 || starB.z + cameraZ <= 0) continue;
                    
                    // Create gradient line
                    const gradient = ctx.createLinearGradient(projA.x, projA.y, projB.x, projB.y);
                    gradient.addColorStop(0, 'rgba(100, 180, 255, ' + (0.2 * connectionPulse) + ')');
                    gradient.addColorStop(1, 'rgba(255, 215, 0, ' + (0.2 * connectionPulse) + ')');
                    
                    // Draw line
                    ctx.beginPath();
                    ctx.moveTo(projA.x, projA.y);
                    ctx.lineTo(projB.x, projB.y);
                    ctx.strokeStyle = gradient;
                    ctx.stroke();
                }
                
                // Draw stars after connections
                stars.forEach(star => {
                    // Project position
                    const proj = project3D(star.x, star.y, star.z);
                    
                    // Skip if behind camera
                    if (star.z + cameraZ <= 0) return;
                    
                    // Calculate size based on distance
                    const size = star.size * proj.factor;
                    
                    // Pulse effect for individual star
                    const pulse = Math.sin(time * star.pulseSpeed + star.pulsePhase) * 0.2 + 0.8;
                    
                    // Draw using same styling as hand landmark constellation
                    const colors = star.isGold ? nodeColors.gold : nodeColors.blue;
                    
                    // Draw glow
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = colors.glow;
                    ctx.fill();
                    
                    // Draw main node
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                    ctx.fillStyle = colors.fill;
                    ctx.fill();
                    
                    // Add white center for sparkle
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, size * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (0.8 * pulse) + ')';
                    ctx.fill();
                });
            });
        }
        
        // Create a shooting star effect
        const shootingStars = [];
        function createShootingStar() {
            const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
            let x, y;
            
            switch(side) {
                case 0: // top
                    x = Math.random() * canvas.width;
                    y = -20;
                    break;
                case 1: // right
                    x = canvas.width + 20;
                    y = Math.random() * canvas.height;
                    break;
                case 2: // bottom
                    x = Math.random() * canvas.width;
                    y = canvas.height + 20;
                    break;
                case 3: // left
                    x = -20;
                    y = Math.random() * canvas.height;
                    break;
            }
            
            // Random direction but generally toward center
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const angleToCenter = Math.atan2(centerY - y, centerX - x);
            const angleVariation = (Math.random() - 0.5) * Math.PI / 2; // Â±45 degrees
            const angle = angleToCenter + angleVariation;
            
            shootingStars.push({
                x: x,
                y: y,
                speed: 300 + Math.random() * 400,
                angle: angle,
                length: 50 + Math.random() * 100,
                width: 1 + Math.random() * 2,
                ttl: 2, // seconds to live
                alpha: 0.7 + Math.random() * 0.3,
                color: {
                    r: 200 + Math.random() * 55,
                    g: 200 + Math.random() * 55,
                    b: 255
                }
            });
        }
        
        // Update and draw shooting stars
        function updateShootingStars() {
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const star = shootingStars[i];
                
                // Update position
                star.x += Math.cos(star.angle) * star.speed * deltaTime;
                star.y += Math.sin(star.angle) * star.speed * deltaTime;
                
                // Update TTL
                star.ttl -= deltaTime;
                
                // Remove if out of bounds or expired
                if (star.ttl <= 0 || 
                    star.x < -100 || star.x > canvas.width + 100 ||
                    star.y < -100 || star.y > canvas.height + 100) {
                    shootingStars.splice(i, 1);
                    continue;
                }
                
                // Calculate trail points
                const trailX = star.x - Math.cos(star.angle) * star.length;
                const trailY = star.y - Math.sin(star.angle) * star.length;
                
                // Draw shooting star
                ctx.beginPath();
                ctx.moveTo(star.x, star.y);
                ctx.lineTo(trailX, trailY);
                
                // Create gradient for trail
                const gradient = ctx.createLinearGradient(star.x, star.y, trailX, trailY);
                const color = star.color;
                gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${star.alpha})`);
                gradient.addColorStop(1, `rgba(${color.r}, ${color.g}, ${color.b}, 0)`);
                
                ctx.strokeStyle = gradient;
                ctx.lineWidth = star.width;
                ctx.stroke();
                
                // Add a small glow at the head
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.width + 1, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${star.alpha})`;
                ctx.fill();
            }
        }
        
        // Draw all connections between trees
        function drawConnections() {
            connections.forEach(conn => {
                const fromTree = dataTrees[conn.from];
                const toTree = dataTrees[conn.to];
                
                // Project the tree base points
                const fromProj = project3D(fromTree.x, fromTree.y, fromTree.z);
                const toProj = project3D(toTree.x, toTree.y, toTree.z);
                
                // Don't draw if either end is behind the camera
                if (fromTree.z + cameraZ <= 0 || toTree.z + cameraZ <= 0) return;
                
                // Calculate multiple control points for more interesting curves
                // Main control point
                const midX = (fromTree.x + toTree.x) / 2;
                const midY = (fromTree.y + toTree.y) / 2 - conn.curveHeight;
                const midZ = (fromTree.z + toTree.z) / 2;
                
                // Second control point for more organic feel
                const secondMidX = midX + Math.sin(time * 0.2 + conn.pulsePhase) * 50;
                const secondMidY = midY + Math.cos(time * 0.3 + conn.pulsePhase) * 30;
                const secondMidZ = midZ + Math.sin(time * 0.25 + conn.pulsePhase) * 50;
                
                // Project the control points
                const controlProj = project3D(midX, midY, midZ);
                const control2Proj = project3D(secondMidX, secondMidY, secondMidZ);
                
                // Pulse effect for connection
                const pulse = Math.sin(time * conn.pulseSpeed + conn.pulsePhase) * 0.3 + 0.7;
                
                // Calculate opacity based on distance
                const avgFactor = (fromProj.factor + toProj.factor) / 2;
                const opacity = conn.color.a * pulse * Math.min(1, avgFactor * 1.5);
                
                // Draw main connection path as a smooth curve
                ctx.beginPath();
                ctx.moveTo(fromProj.x, fromProj.y);
                // Use bezier curve for more organic feel
                ctx.bezierCurveTo(
                    controlProj.x, controlProj.y,
                    control2Proj.x, control2Proj.y,
                    toProj.x, toProj.y
                );
                
                // Create a gradient along the path
                const gradient = ctx.createLinearGradient(fromProj.x, fromProj.y, toProj.x, toProj.y);
                gradient.addColorStop(0, `rgba(${conn.color.r}, ${conn.color.g + 20}, ${conn.color.b + 40}, ${opacity})`);
                gradient.addColorStop(0.5, `rgba(${conn.color.r + 30}, ${conn.color.g + 50}, ${conn.color.b + 60}, ${opacity * 0.8})`);
                gradient.addColorStop(1, `rgba(${conn.color.r + 10}, ${conn.color.g + 30}, ${conn.color.b + 50}, ${opacity})`);
                
                // Draw glowing path
                ctx.strokeStyle = gradient;
                ctx.lineWidth = conn.width * avgFactor * pulse;
                ctx.lineCap = 'round';
                ctx.stroke();
                
                // Add glow effect
                ctx.shadowColor = `rgba(${conn.color.r + 50}, ${conn.color.g + 80}, ${conn.color.b + 100}, ${0.5 * pulse})`;
                ctx.shadowBlur = conn.width * avgFactor * 3;
                ctx.stroke();
                ctx.shadowBlur = 0;
                
                // Draw secondary ethereal paths (thinner, more transparent)
                const numEtherealPaths = 2;
                for (let i = 0; i < numEtherealPaths; i++) {
                    // Create offset paths using sin/cos based on time
                    const offsetFactor = i + 1;
                    const waveAmplitude = 15 + Math.sin(time * 0.5) * 5;
                    
                    ctx.beginPath();
                    ctx.moveTo(fromProj.x, fromProj.y);
                    
                    // Calculate control points with offset
                    const offsetX1 = controlProj.x + Math.sin(time * 0.3 + i) * waveAmplitude * offsetFactor;
                    const offsetY1 = controlProj.y + Math.cos(time * 0.4 + i) * waveAmplitude * offsetFactor;
                    
                    const offsetX2 = control2Proj.x + Math.cos(time * 0.3 + i + Math.PI) * waveAmplitude * offsetFactor;
                    const offsetY2 = control2Proj.y + Math.sin(time * 0.4 + i + Math.PI) * waveAmplitude * offsetFactor;
                    
                    // Create ethereal path
                    ctx.bezierCurveTo(
                        offsetX1, offsetY1,
                        offsetX2, offsetY2,
                        toProj.x, toProj.y
                    );
                    
                    // Create a semi-transparent gradient for ethereal effect
                    const etherGradient = ctx.createLinearGradient(fromProj.x, fromProj.y, toProj.x, toProj.y);
                    etherGradient.addColorStop(0, `rgba(${conn.color.r + 70}, ${conn.color.g + 100}, ${conn.color.b + 130}, ${opacity * 0.3})`);
                    etherGradient.addColorStop(0.5, `rgba(${conn.color.r + 100}, ${conn.color.g + 130}, ${conn.color.b + 180}, ${opacity * 0.1})`);
                    etherGradient.addColorStop(1, `rgba(${conn.color.r + 70}, ${conn.color.g + 100}, ${conn.color.b + 130}, ${opacity * 0.3})`);
                    
                    ctx.strokeStyle = etherGradient;
                    ctx.lineWidth = (conn.width * avgFactor * 0.7) / (offsetFactor);
                    ctx.stroke();
                }
                
                // Draw data packets moving along the connection
                drawDataPackets(conn, fromProj, controlProj, toProj, control2Proj);
            });
        }
        
        // Draw data packets moving along connections
        function drawDataPackets(conn, fromProj, controlProj, toProj, control2Proj) {
            // Update and draw each data packet
            for (let i = 0; i < conn.dataPackets.length; i++) {
                const packet = conn.dataPackets[i];
                
                // Move packet along the path
                if (packet.direction === 0) {
                    // Moving from->to
                    packet.position += packet.speed * deltaTime;
                    if (packet.position > 1) {
                        packet.position = 0;
                        // Occasionally reverse direction
                        if (Math.random() < 0.2) packet.direction = 1;
                    }
                } else {
                    // Moving to->from
                    packet.position -= packet.speed * deltaTime;
                    if (packet.position < 0) {
                        packet.position = 1;
                        // Occasionally reverse direction
                        if (Math.random() < 0.2) packet.direction = 0;
                    }
                }
                
                // Calculate point along the bezier curve
                // For a cubic bezier curve, the formula is:
                // P = (1-t)Â³*P0 + 3(1-t)Â²*t*P1 + 3(1-t)*tÂ²*P2 + tÂ³*P3
                const t = packet.position;
                const mt = 1 - t;
                
                // Cubic bezier calculation
                const x = mt*mt*mt*fromProj.x + 
                          3*mt*mt*t*controlProj.x + 
                          3*mt*t*t*control2Proj.x + 
                          t*t*t*toProj.x;
                          
                const y = mt*mt*mt*fromProj.y + 
                          3*mt*mt*t*controlProj.y + 
                          3*mt*t*t*control2Proj.y + 
                          t*t*t*toProj.y;
                
                // Calculate average projection factor for this point
                const avgFactor = fromProj.factor * (1 - t) + toProj.factor * t;
                
                // Pulse effect with slight variation per packet
                const pulse = Math.sin(time * 3 + i * 0.5) * 0.15 + 0.85;
                
                // Draw packet with simplified glow effect
                const size = packet.size * avgFactor * pulse;
                
                // Glowing core
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${packet.color.r}, ${packet.color.g}, ${packet.color.b}, ${packet.color.a * pulse})`;
                ctx.fill();
                
                // Simpler glow - just one layer
                ctx.beginPath();
                ctx.arc(x, y, size * 2, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${packet.color.r}, ${packet.color.g}, ${packet.color.b}, ${packet.color.a * 0.3 * pulse})`;
                ctx.fill();
                
                // Skip additional layers and trail effects for better performance
            }
        }
        
        // Draw a single data tree
        function drawTree(tree) {
            // Don't draw if behind camera
            if (tree.z + cameraZ <= 0) return;
            
            // Project base position
            const baseProj = project3D(tree.x, tree.y, tree.z);
            const topY = tree.y - tree.height; // y increases downward in canvas
            const topProj = project3D(tree.x, topY, tree.z);
            
            // Calculate tree width at this distance
            const scaledWidth = tree.width * baseProj.factor;
            
            // Calculate hover animation offset
            tree.hoverOffset = Math.sin(time * 0.5 + tree.pulsePhase) * 5;
            
            // Draw translucent trunk
            drawTrunk(tree, baseProj, topProj, scaledWidth);
            
            // Draw branches
            tree.branches.forEach(branch => {
                drawBranch(tree, branch, baseProj.factor);
            });
            
            // Draw spirits trapped inside the tree
            tree.spirits.forEach(spirit => {
                drawSpirit(tree, spirit, baseProj.factor);
            });
            
            // Sort leaves by z-distance for proper depth rendering
            const sortedLeaves = [...tree.leaves].sort((a, b) => {
                // Calculate 3D positions
                const aPos = getLeafPosition(tree, a);
                const bPos = getLeafPosition(tree, b);
                // Sort back to front (further objects drawn first)
                return bPos.z - aPos.z;
            });
            
            // Draw leaves last (on top)
            sortedLeaves.forEach(leaf => {
                drawLeaf(tree, leaf, baseProj.factor);
            });
        }
        
        // Helper function to get 3D position of a leaf
        function getLeafPosition(tree, leaf) {
            const branchY = tree.y - leaf.position.h;
            const perpAngle = leaf.position.branchAngle + Math.PI/2;
            const offsetDistance = leaf.offset || 0;
            
            // Base position along branch
            const baseX = tree.x + Math.cos(leaf.position.branchAngle) * leaf.position.r;
            const baseY = branchY + Math.sin(leaf.position.branchAngle) * leaf.position.r * 0.3;
            const baseZ = tree.z + Math.sin(leaf.position.branchAngle) * leaf.position.r;
            
            // Apply perpendicular offset
            const x = baseX + Math.cos(perpAngle) * offsetDistance;
            const y = baseY + Math.sin(perpAngle) * offsetDistance * 0.3;
            const z = baseZ + Math.sin(perpAngle) * offsetDistance;
            
            return { x, y, z };
        }
        
        // Draw the main trunk of a data tree
        function drawTrunk(tree, baseProj, topProj, scaledWidth) {
            // Basic shape
            ctx.beginPath();
            ctx.moveTo(baseProj.x - scaledWidth/2, baseProj.y); 
            ctx.lineTo(baseProj.x + scaledWidth/2, baseProj.y);
            // Taper the top to 60% of base width
            ctx.lineTo(topProj.x + scaledWidth*0.3, topProj.y + tree.hoverOffset);
            ctx.lineTo(topProj.x - scaledWidth*0.3, topProj.y + tree.hoverOffset);
            ctx.closePath();
            
            // Pulse effect for glow
            const pulse = Math.sin(time + tree.pulsePhase) * 0.2 + 0.8;
            
            // Create gradient
            const gradient = ctx.createLinearGradient(
                baseProj.x, baseProj.y, 
                topProj.x, topProj.y
            );
            gradient.addColorStop(0, `rgba(${tree.color.r}, ${tree.color.g}, ${tree.color.b}, ${tree.color.a * 0.8})`);
            gradient.addColorStop(1, `rgba(${tree.color.r + 30}, ${tree.color.g + 30}, ${tree.color.b + 50}, ${tree.color.a * 0.5})`);
            
            // Fill with translucent color
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw ghost layer effects (multiple transparent layers)
            for (let i = 0; i < tree.ghostLayers; i++) {
                const layerOffset = (i + 1) * 8 * pulse;
                
                ctx.beginPath();
                ctx.moveTo(baseProj.x - scaledWidth/2 - layerOffset, baseProj.y); 
                ctx.lineTo(baseProj.x + scaledWidth/2 + layerOffset, baseProj.y);
                ctx.lineTo(topProj.x + scaledWidth*0.3 + layerOffset*0.5, topProj.y + tree.hoverOffset); 
                ctx.lineTo(topProj.x - scaledWidth*0.3 - layerOffset*0.5, topProj.y + tree.hoverOffset);
                ctx.closePath();
                
                const alpha = tree.ghostAlpha * (1 - i/tree.ghostLayers) * pulse;
                ctx.fillStyle = `rgba(${tree.color.r + 20}, ${tree.color.g + 40}, ${tree.color.b + 70}, ${alpha})`;
                ctx.fill();
            }
            
            // Add glow around the tree
            const glowSize = scaledWidth * (0.5 + pulse * 0.5) * tree.glowIntensity;
            const glowGradient = ctx.createRadialGradient(
                baseProj.x, (baseProj.y + topProj.y) / 2, 0,
                baseProj.x, (baseProj.y + topProj.y) / 2, glowSize
            );
            
            glowGradient.addColorStop(0, `rgba(${tree.glowColor.r}, ${tree.glowColor.g}, ${tree.glowColor.b}, ${0.2 * pulse})`);
            glowGradient.addColorStop(1, `rgba(${tree.glowColor.r}, ${tree.glowColor.g}, ${tree.glowColor.b}, 0)`);
            
            ctx.fillStyle = glowGradient;
            ctx.fillRect(
                baseProj.x - glowSize, 
                topProj.y - glowSize + tree.hoverOffset, 
                glowSize * 2, 
                (baseProj.y - topProj.y) + glowSize * 2
            );
        }
        
        // Draw a branch extending from the trunk
        function drawBranch(tree, branch, scaleFactor) {
            // Calculate branch start position on trunk
            const branchY = tree.y - branch.startHeight;
            const startProj = project3D(tree.x, branchY, tree.z);
            
            // Calculate branch end position
            // Apply some swaying motion
            const swayAmount = branch.swayAmount * Math.sin(time * branch.swaySpeed + branch.swayPhase);
            const branchAngle = branch.angle + swayAmount * 0.05;
            
            const endX = tree.x + Math.cos(branchAngle) * branch.length;
            const endY = branchY + Math.sin(branchAngle) * branch.length * 0.3; // Less vertical to look more natural
            const endZ = tree.z + Math.sin(branchAngle) * branch.length;
            
            const endProj = project3D(endX, endY, endZ);
            
            // Calculate branch thickness at this distance
            const thickness = branch.thickness * scaleFactor;
            
            // Draw the branch as a tapered line
            ctx.beginPath();
            ctx.moveTo(startProj.x, startProj.y + tree.hoverOffset * 0.7);
            
            // For segmented branches, draw multiple segments
            if (branch.branchSegments > 1) {
                // Create segmented branch with slight curves
                for (let i = 1; i <= branch.branchSegments; i++) {
                    const t = i / branch.branchSegments;
                    // Add some randomization to the segments
                    const segX = startProj.x + (endProj.x - startProj.x) * t + Math.sin(t * Math.PI * 2 + branch.swayPhase) * thickness * 0.5;
                    const segY = startProj.y + (endProj.y - startProj.y) * t + Math.cos(t * Math.PI + branch.swayPhase) * thickness * 0.3;
                    
                    ctx.lineTo(segX, segY + tree.hoverOffset * (1 - t));
                }
            } else {
                // Just draw straight to end
                ctx.lineTo(endProj.x, endProj.y + tree.hoverOffset * 0.3);
            }
            
            // Line properties
            const color = tree.color;
            const pulse = Math.sin(time * 0.8 + branch.swayPhase) * 0.15 + 0.85;
            ctx.strokeStyle = `rgba(${color.r + 20}, ${color.g + 40}, ${color.b + 50}, ${color.a * pulse})`;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // Add glow effect
            ctx.shadowColor = `rgba(${color.r + 50}, ${color.g + 80}, ${color.b + 100}, ${0.5 * pulse})`;
            ctx.shadowBlur = thickness * 2;
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset shadow blur
        }
        
        // Draw a spirit trapped inside the tree
        function drawSpirit(tree, spirit, scaleFactor) {
            // Calculate base position and then orbit based on time
            const baseY = tree.y - spirit.height;
            
            // Orbit around the center of the tree
            const orbitAngle = spirit.angle + time * spirit.orbitSpeed;
            const x = tree.x + Math.cos(orbitAngle) * spirit.radius;
            const y = baseY;
            const z = tree.z + Math.sin(orbitAngle) * spirit.radius;
            
            // Project to screen space
            const proj = project3D(x, y, z);
            
            // Calculate size based on distance
            const size = spirit.size * scaleFactor;
            
            // Pulse animation
            const pulse = Math.sin(time * spirit.pulseSpeed + spirit.pulsePhase) * 0.3 + 0.7;
            
            // Draw the spirit as a glowing orb
            const gradient = ctx.createRadialGradient(
                proj.x, proj.y + tree.hoverOffset * 0.5, 0,
                proj.x, proj.y + tree.hoverOffset * 0.5, size * spirit.glowSize
            );
            
            const color = spirit.color;
            gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a * pulse})`);
            gradient.addColorStop(0.6, `rgba(${color.r * 0.8}, ${color.g * 0.8}, ${color.b}, ${color.a * 0.5 * pulse})`);
            gradient.addColorStop(1, `rgba(${color.r * 0.6}, ${color.g * 0.6}, ${color.b}, 0)`);
            
            ctx.beginPath();
            ctx.arc(proj.x, proj.y + tree.hoverOffset * 0.5, size * spirit.glowSize, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            
            // Draw inner core
            ctx.beginPath();
            ctx.arc(proj.x, proj.y + tree.hoverOffset * 0.5, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.7 * pulse})`;
            ctx.fill();
            
            // Draw flow particles orbiting the spirit
            spirit.flowParticles.forEach((particle, i) => {
                const particleAngle = time * particle.speed + particle.offset;
                const px = proj.x + Math.cos(particleAngle) * particle.distance * scaleFactor;
                const py = proj.y + Math.sin(particleAngle) * particle.distance * scaleFactor + tree.hoverOffset * 0.5;
                
                // Pulse effect for particle
                const particlePulse = Math.sin(time * 3 + i) * 0.3 + 0.7;
                
                ctx.beginPath();
                ctx.arc(px, py, particle.size * scaleFactor, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${particle.opacity * particlePulse})`;
                ctx.fill();
            });
        }
        
        // Draw a leaf (Wikipedia data fragment)
        function drawLeaf(tree, leaf, scaleFactor) {
            // Skip if leaf image isn't loaded yet or has an error
            if (leafImages.length <= leaf.imageIndex || 
                !leafImages[leaf.imageIndex].complete || 
                leafImages[leaf.imageIndex].naturalWidth === 0) {
                return;
            }
            
            // Calculate position based on placement data
            const leafPosition = getLeafPosition(tree, leaf);
            const x = leafPosition.x;
            const y = leafPosition.y;
            const z = leafPosition.z;
            
            // Add hover animation effect
            const hoverOffset = tree.hoverOffset * (1 - leaf.position.h / tree.height);
            
            // Graceful hover animation
            const leafHover = Math.sin(time * leaf.hoverFrequency + leaf.pulsePhase) * leaf.hoverAmplitude;
            
            // Project to screen space
            const proj = project3D(x, y, z);
            
            // Calculate size based on distance - make leaves larger for better clarity
            const size = leaf.size * scaleFactor * 1.2;
            
            // Calculate rotation (combine base rotation with animation)
            leaf.currentRotation += leaf.rotationSpeed * deltaTime;
            
            // Limit rotation to maxRotation (default: 45 degrees) to ensure readability
            const maxRotation = leaf.maxRotation || Math.PI / 4; // 45 degrees
            if (Math.abs(leaf.currentRotation) > maxRotation) {
                // If exceeded, reset to max value with the same sign
                leaf.currentRotation = Math.sign(leaf.currentRotation) * maxRotation;
                // And reverse direction
                leaf.rotationSpeed = -leaf.rotationSpeed;
            }
            
            // Pulse animation for opacity
            const pulse = Math.sin(time * 0.5 + leaf.pulsePhase) * 0.1 + 0.9;
            
            // Only draw if leaf is in view and reasonably sized
            if (proj.x < -size || proj.x > canvas.width + size || 
                proj.y < -size || proj.y > canvas.height + size ||
                size < 2) {
                return;
            }
            
            // Draw the leaf image with rotation
            ctx.save();
            ctx.translate(proj.x, proj.y + hoverOffset + leafHover);
            ctx.rotate(leaf.currentRotation);
            
            // Use global alpha for overall opacity - increase base opacity for better visibility
            const baseOpacity = Math.min(1.0, leaf.opacity * 1.2) * pulse;
            ctx.globalAlpha = baseOpacity;
            
            // Draw the leaf image
            const leafImage = leafImages[leaf.imageIndex];
            
            // Improved drawing with less transparent tint
            if (leaf.tint && leaf.tint.strength > 0) {
                // Apply tint using globalCompositeOperation for better performance
                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(leafImage, -size/2, -size/2, size, size);
                
                // Overlay tint color with reduced strength for better clarity
                ctx.globalCompositeOperation = 'overlay';
                ctx.fillStyle = `rgba(${leaf.tint.r}, ${leaf.tint.g}, ${leaf.tint.b}, ${leaf.tint.strength * 0.7})`;
                ctx.fillRect(-size/2, -size/2, size, size);
                
                // Reset composite operation
                ctx.globalCompositeOperation = 'source-over';
            } else {
                // Normal draw without tint
                ctx.drawImage(leafImage, -size/2, -size/2, size, size);
            }
            
            // Add a subtle glow effect
            if (size > 20) {
                ctx.globalAlpha = baseOpacity * 0.3;
                ctx.filter = 'blur(3px)'; // Further reduced blur for sharper appearance
                ctx.drawImage(
                    leafImage, 
                    -size/2 - 8, -size/2 - 8, 
                    size + 16, size + 16
                );
            }
            
            // Reset context
            ctx.filter = 'none';
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        
        // Draw hand landmarks for visual feedback
        function drawHandLandmarks() {
            if (!handLandmarks) return;
            
            // Define colors for constellation effect
            const nodeColors = {
                blue: {
                    fill: 'rgba(100, 180, 255, 0.7)',
                    glow: 'rgba(60, 150, 255, 0.3)'
                },
                gold: {
                    fill: 'rgba(255, 215, 0, 0.7)',
                    glow: 'rgba(255, 190, 0, 0.3)'
                }
            };
            
            // Create constellation effect
            ctx.save();
            
            // Draw connections first (as constellation lines)
            ctx.lineWidth = 1.5;
            ctx.lineCap = 'round';
            
            // Define finger connections for constellation
            const fingerConnections = [
                // Thumb
                [0, 1], [1, 2], [2, 3], [3, 4],
                // Index
                [0, 5], [5, 6], [6, 7], [7, 8],
                // Middle
                [5, 9], [9, 10], [10, 11], [11, 12],
                // Ring
                [9, 13], [13, 14], [14, 15], [15, 16],
                // Pinky
                [13, 17], [17, 18], [18, 19], [19, 20],
                // Palm
                [0, 5], [5, 9], [9, 13], [13, 17]
            ];
            
            // Draw connections as subtle gradient lines
            for (const [i, j] of fingerConnections) {
                if (i >= handLandmarks.length || j >= handLandmarks.length) continue;
                
                const x1 = handLandmarks[i].x * canvas.width;
                const y1 = handLandmarks[i].y * canvas.height;
                const x2 = handLandmarks[j].x * canvas.width;
                const y2 = handLandmarks[j].y * canvas.height;
                
                // Create gradient line
                const gradient = ctx.createLinearGradient(x1, y1, x2, y2);
                gradient.addColorStop(0, 'rgba(100, 180, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 215, 0, 0.3)');
                
                // Draw line with glow effect
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = gradient;
                ctx.stroke();
            }
            
            // Add subtle glow effect to lines
            ctx.shadowColor = 'rgba(160, 200, 255, 0.3)';
            ctx.shadowBlur = 5;
            
            // Draw small stars at key joints (fingertips, knuckles)
            const keyPoints = [4, 8, 12, 16, 20]; // Fingertips
            const secondaryPoints = [2, 6, 10, 14, 18]; // Middle joints
            
            // Draw fingertips as gold stars
            for (const i of keyPoints) {
                if (i >= handLandmarks.length) continue;
                
                const x = handLandmarks[i].x * canvas.width;
                const y = handLandmarks[i].y * canvas.height;
                
                // Draw gold node with glow
                drawConstellationNode(x, y, 5, nodeColors.gold);
            }
            
            // Draw knuckles as blue stars
            for (const i of secondaryPoints) {
                if (i >= handLandmarks.length) continue;
                
                const x = handLandmarks[i].x * canvas.width;
                const y = handLandmarks[i].y * canvas.height;
                
                // Draw blue node with glow
                drawConstellationNode(x, y, 4, nodeColors.blue);
            }
            
            // Draw other nodes as smaller blue dots
            for (let i = 0; i < handLandmarks.length; i++) {
                if (keyPoints.includes(i) || secondaryPoints.includes(i)) continue;
                
                const x = handLandmarks[i].x * canvas.width;
                const y = handLandmarks[i].y * canvas.height;
                
                // Draw smaller blue node
                drawConstellationNode(x, y, 3, nodeColors.blue);
            }
            
            ctx.restore();
        }
        
        // Helper function to draw constellation nodes
        function drawConstellationNode(x, y, size, colors) {
            // Draw glow
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            ctx.fillStyle = colors.glow;
            ctx.fill();
            
            // Draw main node
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fillStyle = colors.fill;
            ctx.fill();
            
            // Add a subtle white center for sparkle
            ctx.beginPath();
            ctx.arc(x, y, size * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
        }
        
        // Initialize scene
        initStars();
        preloadLeafImages();
        createDataTrees();
        
        // Start animation
        requestAnimationFrame(animate);
        
        // Add initial entrance animation for empty forest
        function createEntranceEffect() {
            // Create constellation-like formations
            setTimeout(() => {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const angle = (i / 5) * Math.PI * 2;
                        const distance = 300 + Math.random() * 200;
                        const x = Math.cos(angle) * distance;
                        const y = Math.sin(angle) * distance * 0.5;
                        const z = 600 + Math.random() * 200;
                        
                        createBinaryBurstEffect(x, y, z, 15);
                        
                        // Create shooting stars
                        if (Math.random() > 0.5) {
                            createShootingStar();
                        }
                    }, i * 500);
                }
            }, 2000);
        }
        
        // Call entrance effect after loading
        createEntranceEffect();
    </script>
</body>
</html> 